{"meta":{"title":"何若のblog","subtitle":"","description":"","author":"何若","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"Java-02-02-10-常用工具类","slug":"liaoxuefeng/02-面向对象编程/02-Java核心类/10-常用工具类","date":"2020-08-05T02:00:00.000Z","updated":"2020-08-15T16:59:12.206Z","comments":true,"path":"2020/08/05/liaoxuefeng/02-面向对象编程/02-Java核心类/10-常用工具类/","link":"","permalink":"http://example.com/2020/08/05/liaoxuefeng/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/02-Java%E6%A0%B8%E5%BF%83%E7%B1%BB/10-%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB/","excerpt":"","text":"Java的核心库提供了大量的现成的类供我们使用。本节我们介绍几个常用的工具类。 Math顾名思义，Math类就是用来进行数学计算的，它提供了大量的静态方法来便于我们实现数学计算： 求绝对值： 12Math.abs(-100); // 100Math.abs(-7.8); // 7.8 取最大或最小值： 12Math.max(100, 99); // 100Math.min(1.2, 2.3); // 1.2 计算xy次方： 1Math.pow(2, 10); // 2的10次方=1024 计算√x： 1Math.sqrt(2); // 1.414... 计算ex次方： 1Math.exp(2); // 7.389... 计算以e为底的对数： 1Math.log(4); // 1.386... 计算以10为底的对数： 1Math.log10(100); // 2 三角函数： 12345Math.sin(3.14); // 0.00159...Math.cos(3.14); // -0.9999...Math.tan(3.14); // -0.0015...Math.asin(1.0); // 1.57079...Math.acos(1.0); // 0.0 Math还提供了几个数学常量： 123double pi = Math.PI; // 3.14159...double e = Math.E; // 2.7182818...Math.sin(Math.PI / 6); // sin(π/6) = 0.5 生成一个随机数x，x的范围是0 &lt;= x &lt; 1： 1Math.random(); // 0.53907... 每次都不一样 如果我们要生成一个区间在[MIN, MAX)的随机数，可以借助Math.random()实现，计算如下： 123456789101112// 区间在[MIN, MAX)的随机数public class Main &#123; public static void main(String[] args) &#123; double x = Math.random(); // x的范围是[0,1) double min = 10; double max = 50; double y = x * (max - min) + min; // y的范围是[10,50) long n = (long) y; // n的范围是[10,50)的整数 System.out.println(y); System.out.println(n); &#125;&#125; 有些童鞋可能注意到Java标准库还提供了一个StrictMath，它提供了和Math几乎一模一样的方法。这两个类的区别在于，由于浮点数计算存在误差，不同的平台（例如x86和ARM）计算的结果可能不一致（指误差不同），因此，StrictMath保证所有平台计算结果都是完全相同的，而Math会尽量针对平台优化计算速度，所以，绝大多数情况下，使用Math就足够了。 RandomRandom用来创建伪随机数。所谓伪随机数，是指只要给定一个初始的种子，产生的随机数序列是完全一样的。 要生成一个随机数，可以使用nextInt()、nextLong()、nextFloat()、nextDouble()： 123456Random r = new Random();r.nextInt(); // 2071575453,每次都不一样r.nextInt(10); // 5,生成一个[0,10)之间的intr.nextLong(); // 8811649292570369305,每次都不一样r.nextFloat(); // 0.54335...生成一个[0,1)之间的floatr.nextDouble(); // 0.3716...生成一个[0,1)之间的double 有童鞋问，每次运行程序，生成的随机数都是不同的，没看出伪随机数的特性来。 这是因为我们创建Random实例时，如果不给定种子，就使用系统当前时间戳作为种子，因此每次运行时，种子不同，得到的伪随机数序列就不同。 如果我们在创建Random实例时指定一个种子，就会得到完全确定的随机数序列： 1234567891011import java.util.Random;public class Main &#123; public static void main(String[] args) &#123; Random r = new Random(12345); for (int i = 0; i &lt; 10; i++) &#123; System.out.println(r.nextInt(100)); &#125; // 51, 80, 41, 28, 55... &#125;&#125; 前面我们使用的Math.random()实际上内部调用了Random类，所以它也是伪随机数，只是我们无法指定种子。 SecureRandom有伪随机数，就有真随机数。实际上真正的真随机数只能通过量子力学原理来获取，而我们想要的是一个不可预测的安全的随机数，SecureRandom就是用来创建安全的随机数的： 12SecureRandom sr = new SecureRandom();System.out.println(sr.nextInt(100)); SecureRandom无法指定种子，它使用RNG（random number generator）算法。JDK的SecureRandom实际上有多种不同的底层实现，有的使用安全随机种子加上伪随机数算法来产生安全的随机数，有的使用真正的随机数生成器。实际使用的时候，可以优先获取高强度的安全随机数生成器，如果没有提供，再使用普通等级的安全随机数生成器： 1234567891011121314151617import java.util.Arrays;import java.security.SecureRandom;import java.security.NoSuchAlgorithmException;public class Main &#123; public static void main(String[] args) &#123; SecureRandom sr = null; try &#123; sr = SecureRandom.getInstanceStrong(); // 获取高强度安全随机数生成器 &#125; catch (NoSuchAlgorithmException e) &#123; sr = new SecureRandom(); // 获取普通的安全随机数生成器 &#125; byte[] buffer = new byte[16]; sr.nextBytes(buffer); // 用安全随机数填充buffer System.out.println(Arrays.toString(buffer)); &#125;&#125; SecureRandom的安全性是通过操作系统提供的安全的随机种子来生成随机数。这个种子是通过CPU的热噪声、读写磁盘的字节、网络流量等各种随机事件产生的“熵”。 在密码学中，安全的随机数非常重要。如果使用不安全的伪随机数，所有加密体系都将被攻破。因此，时刻牢记必须使用SecureRandom来产生安全的随机数。 需要使用安全随机数的时候，必须使用SecureRandom，绝不能使用Random！ 小结Java提供的常用工具类有： Math：数学计算 Random：生成伪随机数 SecureRandom：生成安全的随机数","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"02-面向对象编程","slug":"Java/02-面向对象编程","permalink":"http://example.com/categories/Java/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"name":"--02-Java核心类","slug":"Java/02-面向对象编程/02-Java核心类","permalink":"http://example.com/categories/Java/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/02-Java%E6%A0%B8%E5%BF%83%E7%B1%BB/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java-02-02-09-BigDecimal","slug":"liaoxuefeng/02-面向对象编程/02-Java核心类/09-BigDecimal","date":"2020-08-05T01:00:00.000Z","updated":"2020-08-15T16:58:34.556Z","comments":true,"path":"2020/08/05/liaoxuefeng/02-面向对象编程/02-Java核心类/09-BigDecimal/","link":"","permalink":"http://example.com/2020/08/05/liaoxuefeng/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/02-Java%E6%A0%B8%E5%BF%83%E7%B1%BB/09-BigDecimal/","excerpt":"","text":"和BigInteger类似，BigDecimal可以表示一个任意大小且精度完全准确的浮点数。 12BigDecimal bd = new BigDecimal(&quot;123.4567&quot;);System.out.println(bd.multiply(bd)); // 15241.55677489 BigDecimal用scale()表示小数位数，例如： 123456BigDecimal d1 = new BigDecimal(&quot;123.45&quot;);BigDecimal d2 = new BigDecimal(&quot;123.4500&quot;);BigDecimal d3 = new BigDecimal(&quot;1234500&quot;);System.out.println(d1.scale()); // 2,两位小数System.out.println(d2.scale()); // 4System.out.println(d3.scale()); // 0 通过BigDecimal的stripTrailingZeros()方法，可以将一个BigDecimal格式化为一个相等的，但去掉了末尾0的BigDecimal： 123456789BigDecimal d1 = new BigDecimal(&quot;123.4500&quot;);BigDecimal d2 = d1.stripTrailingZeros();System.out.println(d1.scale()); // 4System.out.println(d2.scale()); // 2,因为去掉了00BigDecimal d3 = new BigDecimal(&quot;1234500&quot;);BigDecimal d4 = d3.stripTrailingZeros();System.out.println(d3.scale()); // 0System.out.println(d4.scale()); // -2 如果一个BigDecimal的scale()返回负数，例如，-2，表示这个数是个整数，并且末尾有2个0。 可以对一个BigDecimal设置它的scale，如果精度比原始值低，那么按照指定的方法进行四舍五入或者直接截断： 12345678910111213import java.math.BigDecimal;import java.math.RoundingMode;public class Main &#123; public static void main(String[] args) &#123; BigDecimal d1 = new BigDecimal(&quot;123.456789&quot;); BigDecimal d2 = d1.setScale(4, RoundingMode.HALF_UP); // 四舍五入，123.4568 BigDecimal d3 = d1.setScale(4, RoundingMode.DOWN); // 直接截断，123.4567 System.out.println(d2); System.out.println(d3); &#125;&#125; 对BigDecimal做加、减、乘时，精度不会丢失，但是做除法时，存在无法除尽的情况，这时，就必须指定精度以及如何进行截断： 1234BigDecimal d1 = new BigDecimal(&quot;123.456&quot;);BigDecimal d2 = new BigDecimal(&quot;23.456789&quot;);BigDecimal d3 = d1.divide(d2, 10, RoundingMode.HALF_UP); // 保留10位小数并四舍五入BigDecimal d4 = d1.divide(d2); // 报错：ArithmeticException，因为除不尽 还可以对BigDecimal做除法的同时求余数： 1234567891011import java.math.BigDecimal;public class Main &#123; public static void main(String[] args) &#123; BigDecimal n = new BigDecimal(&quot;12.345&quot;); BigDecimal m = new BigDecimal(&quot;0.12&quot;); BigDecimal[] dr = n.divideAndRemainder(m); System.out.println(dr[0]); // 102 System.out.println(dr[1]); // 0.105 &#125;&#125; 调用divideAndRemainder()方法时，返回的数组包含两个BigDecimal，分别是商和余数，其中商总是整数，余数不会大于除数。我们可以利用这个方法判断两个BigDecimal是否是整数倍数： 123456BigDecimal n = new BigDecimal(&quot;12.75&quot;);BigDecimal m = new BigDecimal(&quot;0.15&quot;);BigDecimal[] dr = n.divideAndRemainder(m);if (dr[1].signum() == 0) &#123; // n是m的整数倍&#125; 比较BigDecimal在比较两个BigDecimal的值是否相等时，要特别注意，使用equals()方法不但要求两个BigDecimal的值相等，还要求它们的scale()相等： 12345BigDecimal d1 = new BigDecimal(&quot;123.456&quot;);BigDecimal d2 = new BigDecimal(&quot;123.45600&quot;);System.out.println(d1.equals(d2)); // false,因为scale不同System.out.println(d1.equals(d2.stripTrailingZeros())); // true,因为d2去除尾部0后scale变为2System.out.println(d1.compareTo(d2)); // 0 必须使用compareTo()方法来比较，它根据两个值的大小分别返回负数、正数和0，分别表示小于、大于和等于。 总是使用compareTo()比较两个BigDecimal的值，不要使用equals()！ 如果查看BigDecimal的源码，可以发现，实际上一个BigDecimal是通过一个BigInteger和一个scale来表示的，即BigInteger表示一个完整的整数，而scale表示小数位数： 1234public class BigDecimal extends Number implements Comparable&lt;BigDecimal&gt; &#123; private final BigInteger intVal; private final int scale;&#125; BigDecimal也是从Number继承的，也是不可变对象。 小结BigDecimal用于表示精确的小数，常用于财务计算； 比较BigDecimal的值是否相等，必须使用compareTo()而不能使用equals()。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"02-面向对象编程","slug":"Java/02-面向对象编程","permalink":"http://example.com/categories/Java/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"name":"--02-Java核心类","slug":"Java/02-面向对象编程/02-Java核心类","permalink":"http://example.com/categories/Java/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/02-Java%E6%A0%B8%E5%BF%83%E7%B1%BB/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java-02-02-08-BigInteger","slug":"liaoxuefeng/02-面向对象编程/02-Java核心类/08-BigInteger","date":"2020-08-05T00:00:00.000Z","updated":"2020-08-15T16:57:47.658Z","comments":true,"path":"2020/08/05/liaoxuefeng/02-面向对象编程/02-Java核心类/08-BigInteger/","link":"","permalink":"http://example.com/2020/08/05/liaoxuefeng/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/02-Java%E6%A0%B8%E5%BF%83%E7%B1%BB/08-BigInteger/","excerpt":"","text":"BigInteger在Java中，由CPU原生提供的整型最大范围是64位long型整数。使用long型整数可以直接通过CPU指令进行计算，速度非常快。 如果我们使用的整数范围超过了long型怎么办？这个时候，就只能用软件来模拟一个大整数。java.math.BigInteger就是用来表示任意大小的整数。BigInteger内部用一个int[]数组来模拟一个非常大的整数： 12BigInteger bi = new BigInteger(&quot;1234567890&quot;);System.out.println(bi.pow(5)); // 2867971860299718107233761438093672048294900000 对BigInteger做运算的时候，只能使用实例方法，例如，加法运算： 123BigInteger i1 = new BigInteger(&quot;1234567890&quot;);BigInteger i2 = new BigInteger(&quot;12345678901234567890&quot;);BigInteger sum = i1.add(i2); // 12345678902469135780 和long型整数运算比，BigInteger不会有范围限制，但缺点是速度比较慢。 也可以把BigInteger转换成long型： 123BigInteger i = new BigInteger(&quot;123456789000&quot;);System.out.println(i.longValue()); // 123456789000System.out.println(i.multiply(i).longValueExact()); // java.lang.ArithmeticException: BigInteger out of long range 使用longValueExact()方法时，如果超出了long型的范围，会抛出ArithmeticException。 BigInteger和Integer、Long一样，也是不可变类，并且也继承自Number类。因为Number定义了转换为基本类型的几个方法： 转换为byte：byteValue() 转换为short：shortValue() 转换为int：intValue() 转换为long：longValue() 转换为float：floatValue() 转换为double：doubleValue() 因此，通过上述方法，可以把BigInteger转换成基本类型。如果BigInteger表示的范围超过了基本类型的范围，转换时将丢失高位信息，即结果不一定是准确的。如果需要准确地转换成基本类型，可以使用intValueExact()、longValueExact()等方法，在转换时如果超出范围，将直接抛出ArithmeticException异常。 如果BigInteger的值甚至超过了float的最大范围（3.4x1038），那么返回的float是什么呢？ 1234567891011// BigInteger to floatimport java.math.BigInteger;public class Main &#123; public static void main(String[] args) &#123; BigInteger n = new BigInteger(&quot;999999&quot;).pow(99); float f = n.floatValue(); System.out.println(f); &#125;&#125; 小结BigInteger用于表示任意大小的整数； BigInteger是不变类，并且继承自Number； 将BigInteger转换成基本类型时可使用longValueExact()等方法保证结果准确。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"02-面向对象编程","slug":"Java/02-面向对象编程","permalink":"http://example.com/categories/Java/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"name":"--02-Java核心类","slug":"Java/02-面向对象编程/02-Java核心类","permalink":"http://example.com/categories/Java/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/02-Java%E6%A0%B8%E5%BF%83%E7%B1%BB/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java-02-02-07-记录类","slug":"liaoxuefeng/02-面向对象编程/02-Java核心类/07-记录类","date":"2020-08-04T23:00:00.000Z","updated":"2020-08-15T16:57:17.866Z","comments":true,"path":"2020/08/05/liaoxuefeng/02-面向对象编程/02-Java核心类/07-记录类/","link":"","permalink":"http://example.com/2020/08/05/liaoxuefeng/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/02-Java%E6%A0%B8%E5%BF%83%E7%B1%BB/07-%E8%AE%B0%E5%BD%95%E7%B1%BB/","excerpt":"","text":"使用String、Integer等类型的时候，这些类型都是不变类，一个不变类具有以下特点： 定义class时使用final，无法派生子类； 每个字段使用final，保证创建实例后无法修改任何字段。 假设我们希望定义一个Point类，有x、y两个变量，同时它是一个不变类，可以这么写： 1234567891011121314151617public final class Point &#123; private final int x; private final int y; public Point(int x, int y) &#123; this.x = x; this.y = y; &#125; public int x() &#123; return this.x; &#125; public int y() &#123; return this.y; &#125;&#125; 为了保证不变类的比较，还需要正确覆写equals()和hashCode()方法，这样才能在集合类中正常使用。后续我们会详细讲解正确覆写equals()和hashCode()，这里演示Point不变类的写法目的是，这些代码写起来都非常简单，但是很繁琐。 record从Java 14开始，引入了新的Record类。我们定义Record类时，使用关键字record。把上述Point类改写为Record类，代码如下： 123456789101112// Recordpublic class Main &#123; public static void main(String[] args) &#123; Point p = new Point(123, 456); System.out.println(p.x()); System.out.println(p.y()); System.out.println(p); &#125;&#125;public record Point(int x, int y) &#123;&#125; 仔细观察Point的定义： 1public record Point(int x, int y) &#123;&#125; 把上述定义改写为class，相当于以下代码： 12345678910111213141516171819202122232425262728public final class Point extends Record &#123; private final int x; private final int y; public Point(int x, int y) &#123; this.x = x; this.y = y; &#125; public int x() &#123; return this.x; &#125; public int y() &#123; return this.y; &#125; public String toString() &#123; return String.format(&quot;Point[x=%s, y=%s]&quot;, x, y); &#125; public boolean equals(Object o) &#123; ... &#125; public int hashCode() &#123; ... &#125;&#125; 除了用final修饰class以及每个字段外，编译器还自动为我们创建了构造方法，和字段名同名的方法，以及覆写toString()、equals()和hashCode()方法。 换句话说，使用record关键字，可以一行写出一个不变类。 和enum类似，我们自己不能直接从Record派生，只能通过record关键字由编译器实现继承。 构造方法编译器默认按照record声明的变量顺序自动创建一个构造方法，并在方法内给字段赋值。那么问题来了，如果我们要检查参数，应该怎么办？ 假设Point类的x、y不允许负数，我们就得给Point的构造方法加上检查逻辑： 1234567public record Point(int x, int y) &#123; public Point &#123; if (x &lt; 0 || y &lt; 0) &#123; throw new IllegalArgumentException(); &#125; &#125;&#125; 注意到方法public Point &#123;...&#125;被称为Compact Constructor，它的目的是让我们编写检查逻辑，编译器最终生成的构造方法如下： 123456789101112public final class Point extends Record &#123; public Point(int x, int y) &#123; // 这是我们编写的Compact Constructor: if (x &lt; 0 || y &lt; 0) &#123; throw new IllegalArgumentException(); &#125; // 这是编译器继续生成的赋值代码: this.x = x; this.y = y; &#125; ...&#125; 作为record的Point仍然可以添加静态方法。一种常用的静态方法是of()方法，用来创建Point： 12345678public record Point(int x, int y) &#123; public static Point of() &#123; return new Point(0, 0); &#125; public static Point of(int x, int y) &#123; return new Point(x, y); &#125;&#125; 这样我们可以写出更简洁的代码： 12var z = Point.of();var p = Point.of(123, 456); 小结从Java 14开始，提供新的record关键字，可以非常方便地定义Data Class： 使用record定义的是不变类； 可以编写Compact Constructor对参数进行验证； 可以定义静态方法。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"02-面向对象编程","slug":"Java/02-面向对象编程","permalink":"http://example.com/categories/Java/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"name":"--02-Java核心类","slug":"Java/02-面向对象编程/02-Java核心类","permalink":"http://example.com/categories/Java/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/02-Java%E6%A0%B8%E5%BF%83%E7%B1%BB/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java-02-02-06-枚举类","slug":"liaoxuefeng/02-面向对象编程/02-Java核心类/06-枚举类","date":"2020-08-04T22:00:00.000Z","updated":"2020-08-15T16:56:53.505Z","comments":true,"path":"2020/08/05/liaoxuefeng/02-面向对象编程/02-Java核心类/06-枚举类/","link":"","permalink":"http://example.com/2020/08/05/liaoxuefeng/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/02-Java%E6%A0%B8%E5%BF%83%E7%B1%BB/06-%E6%9E%9A%E4%B8%BE%E7%B1%BB/","excerpt":"","text":"在Java中，我们可以通过static final来定义常量。例如，我们希望定义周一到周日这7个常量，可以用7个不同的int表示： 123456789public class Weekday &#123; public static final int SUN = 0; public static final int MON = 1; public static final int TUE = 2; public static final int WED = 3; public static final int THU = 4; public static final int FRI = 5; public static final int SAT = 6;&#125; 使用常量的时候，可以这么引用： 123if (day == Weekday.SAT || day == Weekday.SUN) &#123; // TODO: work at home&#125; 也可以把常量定义为字符串类型，例如，定义3种颜色的常量： 12345public class Color &#123; public static final String RED = &quot;r&quot;; public static final String GREEN = &quot;g&quot;; public static final String BLUE = &quot;b&quot;;&#125; 使用常量的时候，可以这么引用： 1234String color = ...if (Color.RED.equals(color)) &#123; // TODO:&#125; 无论是int常量还是String常量，使用这些常量来表示一组枚举值的时候，有一个严重的问题就是，编译器无法检查每个值的合理性。例如： 12345if (weekday == 6 || weekday == 7) &#123; if (tasks == Weekday.MON) &#123; // TODO: &#125;&#125; 上述代码编译和运行均不会报错，但存在两个问题： 注意到Weekday定义的常量范围是0~6，并不包含7，编译器无法检查不在枚举中的int值； 定义的常量仍可与其他变量比较，但其用途并非是枚举星期值。 enum为了让编译器能自动检查某个值在枚举的集合内，并且，不同用途的枚举需要不同的类型来标记，不能混用，我们可以使用enum来定义枚举类： 12345678910111213141516// enumpublic class Main &#123; public static void main(String[] args) &#123; Weekday day = Weekday.SUN; if (day == Weekday.SAT || day == Weekday.SUN) &#123; System.out.println(&quot;Work at home!&quot;); &#125; else &#123; System.out.println(&quot;Work at office!&quot;); &#125; &#125;&#125;enum Weekday &#123; SUN, MON, TUE, WED, THU, FRI, SAT;&#125; 注意到定义枚举类是通过关键字enum实现的，我们只需依次列出枚举的常量名。 和int定义的常量相比，使用enum定义枚举有如下好处： 首先，enum常量本身带有类型信息，即Weekday.SUN类型是Weekday，编译器会自动检查出类型错误。例如，下面的语句不可能编译通过： 123int day = 1;if (day == Weekday.SUN) &#123; // Compile error: bad operand types for binary operator &#x27;==&#x27;&#125; 其次，不可能引用到非枚举的值，因为无法通过编译。 最后，不同类型的枚举不能互相比较或者赋值，因为类型不符。例如，不能给一个Weekday枚举类型的变量赋值为Color枚举类型的值： 12Weekday x = Weekday.SUN; // ok!Weekday y = Color.RED; // Compile error: incompatible types 这就使得编译器可以在编译期自动检查出所有可能的潜在错误。 enum的比较使用enum定义的枚举类是一种引用类型。前面我们讲到，引用类型比较，要使用equals()方法，如果使用==比较，它比较的是两个引用类型的变量是否是同一个对象。因此，引用类型比较，要始终使用equals()方法，但enum类型可以例外。 这是因为enum类型的每个常量在JVM中只有一个唯一实例，所以可以直接用==比较： 1234if (day == Weekday.FRI) &#123; // ok!&#125;if (day.equals(Weekday.SUN)) &#123; // ok, but more code!&#125; enum类型通过enum定义的枚举类，和其他的class有什么区别？ 答案是没有任何区别。enum定义的类型就是class，只不过它有以下几个特点： 定义的enum类型总是继承自java.lang.Enum，且无法被继承； 只能定义出enum的实例，而无法通过new操作符创建enum的实例； 定义的每个实例都是引用类型的唯一实例； 可以将enum类型用于switch语句。 例如，我们定义的Color枚举类： 123public enum Color &#123; RED, GREEN, BLUE;&#125; 编译器编译出的class大概就像这样： 12345678public final class Color extends Enum &#123; // 继承自Enum，标记为final class // 每个实例均为全局唯一: public static final Color RED = new Color(); public static final Color GREEN = new Color(); public static final Color BLUE = new Color(); // private构造方法，确保外部无法调用new操作符: private Color() &#123;&#125;&#125; 所以，编译后的enum类和普通class并没有任何区别。但是我们自己无法按定义普通class那样来定义enum，必须使用enum关键字，这是Java语法规定的。 因为enum是一个class，每个枚举的值都是class实例，因此，这些实例有一些方法： name()返回常量名，例如： 1String s = Weekday.SUN.name(); // &quot;SUN&quot; ordinal()返回定义的常量的顺序，从0开始计数，例如： 1int n = Weekday.MON.ordinal(); // 1 改变枚举常量定义的顺序就会导致ordinal()返回值发生变化。例如： 123public enum Weekday &#123; SUN, MON, TUE, WED, THU, FRI, SAT;&#125; 和 123public enum Weekday &#123; MON, TUE, WED, THU, FRI, SAT, SUN;&#125; 的ordinal就是不同的。如果在代码中编写了类似if(x.ordinal()==1)这样的语句，就要保证enum的枚举顺序不能变。新增的常量必须放在最后。 有些童鞋会想，Weekday的枚举常量如果要和int转换，使用ordinal()不是非常方便？比如这样写： 12String task = Weekday.MON.ordinal() + &quot;/ppt&quot;;saveToFile(task); 但是，如果不小心修改了枚举的顺序，编译器是无法检查出这种逻辑错误的。要编写健壮的代码，就不要依靠ordinal()的返回值。因为enum本身是class，所以我们可以定义private的构造方法，并且，给每个枚举常量添加字段： 12345678910111213141516171819202122// enumpublic class Main &#123; public static void main(String[] args) &#123; Weekday day = Weekday.SUN; if (day.dayValue == 6 || day.dayValue == 0) &#123; System.out.println(&quot;Work at home!&quot;); &#125; else &#123; System.out.println(&quot;Work at office!&quot;); &#125; &#125;&#125;enum Weekday &#123; MON(1), TUE(2), WED(3), THU(4), FRI(5), SAT(6), SUN(0); public final int dayValue; private Weekday(int dayValue) &#123; this.dayValue = dayValue; &#125;&#125; 这样就无需担心顺序的变化，新增枚举常量时，也需要指定一个int值。 注意：枚举类的字段也可以是非final类型，即可以在运行期修改，但是不推荐这样做！ 默认情况下，对枚举常量调用toString()会返回和name()一样的字符串。但是，toString()可以被覆写，而name()则不行。我们可以给Weekday添加toString()方法： 1234567891011121314151617181920212223242526272829// enumpublic class Main &#123; public static void main(String[] args) &#123; Weekday day = Weekday.SUN; if (day.dayValue == 6 || day.dayValue == 0) &#123; System.out.println(&quot;Today is &quot; + day + &quot;. Work at home!&quot;); &#125; else &#123; System.out.println(&quot;Today is &quot; + day + &quot;. Work at office!&quot;); &#125; &#125;&#125;enum Weekday &#123; MON(1, &quot;星期一&quot;), TUE(2, &quot;星期二&quot;), WED(3, &quot;星期三&quot;), THU(4, &quot;星期四&quot;), FRI(5, &quot;星期五&quot;), SAT(6, &quot;星期六&quot;), SUN(0, &quot;星期日&quot;); public final int dayValue; private final String chinese; private Weekday(int dayValue, String chinese) &#123; this.dayValue = dayValue; this.chinese = chinese; &#125; @Override public String toString() &#123; return this.chinese; &#125;&#125; 覆写toString()的目的是在输出时更有可读性。 注意：判断枚举常量的名字，要始终使用name()方法，绝不能调用toString()！ switch最后，枚举类可以应用在switch语句中。因为枚举类天生具有类型信息和有限个枚举常量，所以比int、String类型更适合用在switch语句中： 1234567891011121314151617181920212223242526// switchpublic class Main &#123; public static void main(String[] args) &#123; Weekday day = Weekday.SUN; switch(day) &#123; case MON: case TUE: case WED: case THU: case FRI: System.out.println(&quot;Today is &quot; + day + &quot;. Work at office!&quot;); break; case SAT: case SUN: System.out.println(&quot;Today is &quot; + day + &quot;. Work at home!&quot;); break; default: throw new RuntimeException(&quot;cannot process &quot; + day); &#125; &#125;&#125;enum Weekday &#123; MON, TUE, WED, THU, FRI, SAT, SUN;&#125; 加上default语句，可以在漏写某个枚举常量时自动报错，从而及时发现错误。 小结Java使用enum定义枚举类型，它被编译器编译为final class Xxx extends Enum &#123; … &#125;； 通过name()获取常量定义的字符串，注意不要使用toString()； 通过ordinal()返回常量定义的顺序（无实质意义）； 可以为enum编写构造方法、字段和方法 enum的构造方法要声明为private，字段强烈建议声明为final； enum适合用在switch语句中。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"02-面向对象编程","slug":"Java/02-面向对象编程","permalink":"http://example.com/categories/Java/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"name":"--02-Java核心类","slug":"Java/02-面向对象编程/02-Java核心类","permalink":"http://example.com/categories/Java/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/02-Java%E6%A0%B8%E5%BF%83%E7%B1%BB/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java-02-02-05-JavaBean","slug":"liaoxuefeng/02-面向对象编程/02-Java核心类/05-JavaBean","date":"2020-08-04T21:00:00.000Z","updated":"2020-08-15T16:56:24.545Z","comments":true,"path":"2020/08/05/liaoxuefeng/02-面向对象编程/02-Java核心类/05-JavaBean/","link":"","permalink":"http://example.com/2020/08/05/liaoxuefeng/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/02-Java%E6%A0%B8%E5%BF%83%E7%B1%BB/05-JavaBean/","excerpt":"","text":"在Java中，有很多class的定义都符合这样的规范： 若干private实例字段； 通过public方法来读写实例字段。 例如： 12345678910public class Person &#123; private String name; private int age; public String getName() &#123; return this.name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return this.age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 如果读写方法符合以下这种命名规范： 1234// 读方法:public Type getXyz()// 写方法:public void setXyz(Type value) 那么这种class被称为JavaBean： 上面的字段是xyz，那么读写方法名分别以get和set开头，并且后接大写字母开头的字段名Xyz，因此两个读写方法名分别是getXyz()和setXyz()。 boolean字段比较特殊，它的读方法一般命名为isXyz()： 1234// 读方法:public boolean isChild()// 写方法:public void setChild(boolean value) 我们通常把一组对应的读方法（getter）和写方法（setter）称为属性（property）。例如，name属性： 对应的读方法是String getName() 对应的写方法是setName(String) 只有getter的属性称为只读属性（read-only），例如，定义一个age只读属性： 对应的读方法是int getAge() 无对应的写方法setAge(int) 类似的，只有setter的属性称为只写属性（write-only）。 很明显，只读属性很常见，只写属性不常见。 属性只需要定义getter和setter方法，不一定需要对应的字段。例如，child只读属性定义如下： 1234567891011121314public class Person &#123; private String name; private int age; public String getName() &#123; return this.name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return this.age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public boolean isChild() &#123; return age &lt;= 6; &#125;&#125; 可以看出，getter和setter也是一种数据封装的方法。 JavaBean的作用JavaBean主要用来传递数据，即把一组数据组合成一个JavaBean便于传输。此外，JavaBean可以方便地被IDE工具分析，生成读写属性的代码，主要用在图形界面的可视化设计中。 通过IDE，可以快速生成getter和setter。例如，在Eclipse中，先输入以下代码： 1234public class Person &#123; private String name; private int age;&#125; 然后，点击右键，在弹出的菜单中选择“Source”，“Generate Getters and Setters”，在弹出的对话框中选中需要生成getter和setter方法的字段，点击确定即可由IDE自动完成所有方法代码。 枚举JavaBean属性要枚举一个JavaBean的所有属性，可以直接使用Java核心库提供的Introspector： 123456789101112131415161718192021222324252627282930313233import java.beans.*;public class Main &#123; public static void main(String[] args) throws Exception &#123; BeanInfo info = Introspector.getBeanInfo(Person.class); for (PropertyDescriptor pd : info.getPropertyDescriptors()) &#123; System.out.println(pd.getName()); System.out.println(&quot; &quot; + pd.getReadMethod()); System.out.println(&quot; &quot; + pd.getWriteMethod()); &#125; &#125;&#125;class Person &#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 运行上述代码，可以列出所有的属性，以及对应的读写方法。注意class属性是从Object继承的getClass()方法带来的。 小结JavaBean是一种符合命名规范的class，它通过getter和setter来定义属性； 属性是一种通用的叫法，并非Java语法规定； 可以利用IDE快速生成getter和setter； 使用Introspector.getBeanInfo()可以获取属性列表。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"02-面向对象编程","slug":"Java/02-面向对象编程","permalink":"http://example.com/categories/Java/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"name":"--02-Java核心类","slug":"Java/02-面向对象编程/02-Java核心类","permalink":"http://example.com/categories/Java/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/02-Java%E6%A0%B8%E5%BF%83%E7%B1%BB/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java-02-02-04-包装类型","slug":"liaoxuefeng/02-面向对象编程/02-Java核心类/04-包装类型","date":"2020-08-04T20:00:00.000Z","updated":"2020-08-15T16:56:00.110Z","comments":true,"path":"2020/08/05/liaoxuefeng/02-面向对象编程/02-Java核心类/04-包装类型/","link":"","permalink":"http://example.com/2020/08/05/liaoxuefeng/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/02-Java%E6%A0%B8%E5%BF%83%E7%B1%BB/04-%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"我们已经知道，Java的数据类型分两种： 基本类型：byte，short，int，long，boolean，float，double，char 引用类型：所有class和interface类型 引用类型可以赋值为null，表示空，但基本类型不能赋值为null： 12String s = null;int n = null; // compile error! 那么，如何把一个基本类型视为对象（引用类型）？ 比如，想要把int基本类型变成一个引用类型，我们可以定义一个Integer类，它只包含一个实例字段int，这样，Integer类就可以视为int的包装类（Wrapper Class）： 1234567891011public class Integer &#123; private int value; public Integer(int value) &#123; this.value = value; &#125; public int intValue() &#123; return this.value; &#125;&#125; 定义好了Integer类，我们就可以把int和Integer互相转换： 123Integer n = null;Integer n2 = new Integer(99);int n3 = n2.intValue(); 实际上，因为包装类型非常有用，Java核心库为每种基本类型都提供了对应的包装类型： 基本类型 对应的引用类型 boolean java.lang.Boolean byte java.lang.Byte short java.lang.Short int java.lang.Integer long java.lang.Long float java.lang.Float double java.lang.Double char java.lang.Character 我们可以直接使用，并不需要自己去定义： 1234567891011121314// Integer:public class Main &#123; public static void main(String[] args) &#123; int i = 100; // 通过new操作符创建Integer实例(不推荐使用,会有编译警告): Integer n1 = new Integer(i); // 通过静态方法valueOf(int)创建Integer实例: Integer n2 = Integer.valueOf(i); // 通过静态方法valueOf(String)创建Integer实例: Integer n3 = Integer.valueOf(&quot;100&quot;); System.out.println(n3.intValue()); &#125;&#125; Auto Boxing因为int和Integer可以互相转换： 123int i = 100;Integer n = Integer.valueOf(i);int x = n.intValue(); 所以，Java编译器可以帮助我们自动在int和Integer之间转型： 12Integer n = 100; // 编译器自动使用Integer.valueOf(int)int x = n; // 编译器自动使用Integer.intValue() 这种直接把int变为Integer的赋值写法，称为自动装箱（Auto Boxing），反过来，把Integer变为int的赋值写法，称为自动拆箱（Auto Unboxing）。 注意：自动装箱和自动拆箱只发生在编译阶段，目的是为了少写代码。 装箱和拆箱会影响代码的执行效率，因为编译后的class代码是严格区分基本类型和引用类型的。并且，自动拆箱执行时可能会报NullPointerException： 12345678// NullPointerExceptionpublic class Main &#123; public static void main(String[] args) &#123; Integer n = null; int i = n; &#125;&#125; 不变类所有的包装类型都是不变类。我们查看Integer的源码可知，它的核心代码如下： 123public final class Integer &#123; private final int value;&#125; 因此，一旦创建了Integer对象，该对象就是不变的。 对两个Integer实例进行比较要特别注意：绝对不能用==比较，因为Integer是引用类型，必须使用equals()比较： 1234567891011121314// == or equals?public class Main &#123; public static void main(String[] args) &#123; Integer x = 127; Integer y = 127; Integer m = 99999; Integer n = 99999; System.out.println(&quot;x == y: &quot; + (x==y)); // true System.out.println(&quot;m == n: &quot; + (m==n)); // false System.out.println(&quot;x.equals(y): &quot; + x.equals(y)); // true System.out.println(&quot;m.equals(n): &quot; + m.equals(n)); // true &#125;&#125; 仔细观察结果的童鞋可以发现，==比较，较小的两个相同的Integer返回true，较大的两个相同的Integer返回false，这是因为Integer是不变类，编译器把Integer x = 127;自动变为Integer x = Integer.valueOf(127);，为了节省内存，Integer.valueOf()对于较小的数，始终返回相同的实例，因此，==比较“恰好”为true，但我们绝不能因为Java标准库的Integer内部有缓存优化就用==比较，必须用equals()方法比较两个Integer。 按照语义编程，而不是针对特定的底层实现去“优化”。 因为Integer.valueOf()可能始终返回同一个Integer实例，因此，在我们自己创建Integer的时候，以下两种方法： 方法1：Integer n = new Integer(100); 方法2：Integer n = Integer.valueOf(100); 方法2更好，因为方法1总是创建新的Integer实例，方法2把内部优化留给Integer的实现者去做，即使在当前版本没有优化，也有可能在下一个版本进行优化。 我们把能创建“新”对象的静态方法称为静态工厂方法。Integer.valueOf()就是静态工厂方法，它尽可能地返回缓存的实例以节省内存。 创建新对象时，优先选用静态工厂方法而不是new操作符。 如果我们考察Byte.valueOf()方法的源码，可以看到，标准库返回的Byte实例全部是缓存实例，但调用者并不关心静态工厂方法以何种方式创建新实例还是直接返回缓存的实例。 进制转换Integer类本身还提供了大量方法，例如，最常用的静态方法parseInt()可以把字符串解析成一个整数： 12int x1 = Integer.parseInt(&quot;100&quot;); // 100int x2 = Integer.parseInt(&quot;100&quot;, 16); // 256,因为按16进制解析 Integer还可以把整数格式化为指定进制的字符串： 1234567891011// Integer:public class Main &#123; public static void main(String[] args) &#123; System.out.println(Integer.toString(100)); // &quot;100&quot;,表示为10进制 System.out.println(Integer.toString(100, 36)); // &quot;2s&quot;,表示为36进制 System.out.println(Integer.toHexString(100)); // &quot;64&quot;,表示为16进制 System.out.println(Integer.toOctalString(100)); // &quot;144&quot;,表示为8进制 System.out.println(Integer.toBinaryString(100)); // &quot;1100100&quot;,表示为2进制 &#125;&#125; 注意：上述方法的输出都是String，在计算机内存中，只用二进制表示，不存在十进制或十六进制的表示方法。int n = 100在内存中总是以4字节的二进制表示： 123┌────────┬────────┬────────┬────────┐│00000000│00000000│00000000│01100100│└────────┴────────┴────────┴────────┘ 我们经常使用的System.out.println(n);是依靠核心库自动把整数格式化为10进制输出并显示在屏幕上，使用Integer.toHexString(n)则通过核心库自动把整数格式化为16进制。 这里我们注意到程序设计的一个重要原则：数据的存储和显示要分离。 Java的包装类型还定义了一些有用的静态变量 123456789// boolean只有两个值true/false，其包装类型只需要引用Boolean提供的静态字段:Boolean t = Boolean.TRUE;Boolean f = Boolean.FALSE;// int可表示的最大/最小值:int max = Integer.MAX_VALUE; // 2147483647int min = Integer.MIN_VALUE; // -2147483648// long类型占用的bit和byte数量:int sizeOfLong = Long.SIZE; // 64 (bits)int bytesOfLong = Long.BYTES; // 8 (bytes) 最后，所有的整数和浮点数的包装类型都继承自Number，因此，可以非常方便地直接通过包装类型获取各种基本类型： 12345678// 向上转型为Number:Number num = new Integer(999);// 获取byte, int, long, float, double:byte b = num.byteValue();int n = num.intValue();long ln = num.longValue();float f = num.floatValue();double d = num.doubleValue(); 处理无符号整型在Java中，并没有无符号整型（Unsigned）的基本数据类型。byte、short、int和long都是带符号整型，最高位是符号位。而C语言则提供了CPU支持的全部数据类型，包括无符号整型。无符号整型和有符号整型的转换在Java中就需要借助包装类型的静态方法完成。 例如，byte是有符号整型，范围是-128 ~ +127，但如果把byte看作无符号整型，它的范围就是0 ~ 255。我们把一个负的byte按无符号整型转换为int： 12345678910// Bytepublic class Main &#123; public static void main(String[] args) &#123; byte x = -1; byte y = 127; System.out.println(Byte.toUnsignedInt(x)); // 255 System.out.println(Byte.toUnsignedInt(y)); // 127 &#125;&#125; 因为byte的-1的二进制表示是11111111，以无符号整型转换后的int就是255。 类似的，可以把一个short按unsigned转换为int，把一个int按unsigned转换为long。 小结Java核心库提供的包装类型可以把基本类型包装为class； 自动装箱和自动拆箱都是在编译期完成的（JDK&gt;=1.5）； 装箱和拆箱会影响执行效率，且拆箱时可能发生NullPointerException； 包装类型的比较必须使用equals()； 整数和浮点数的包装类型都继承自Number； 包装类型提供了大量实用方法。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"02-面向对象编程","slug":"Java/02-面向对象编程","permalink":"http://example.com/categories/Java/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"name":"--02-Java核心类","slug":"Java/02-面向对象编程/02-Java核心类","permalink":"http://example.com/categories/Java/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/02-Java%E6%A0%B8%E5%BF%83%E7%B1%BB/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java-02-02-03-StringJoiner","slug":"liaoxuefeng/02-面向对象编程/02-Java核心类/03-StringJoiner","date":"2020-08-04T19:00:00.000Z","updated":"2020-08-15T16:55:32.779Z","comments":true,"path":"2020/08/05/liaoxuefeng/02-面向对象编程/02-Java核心类/03-StringJoiner/","link":"","permalink":"http://example.com/2020/08/05/liaoxuefeng/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/02-Java%E6%A0%B8%E5%BF%83%E7%B1%BB/03-StringJoiner/","excerpt":"","text":"要高效拼接字符串，应该使用StringBuilder。 很多时候，我们拼接的字符串像这样： 12345678910111213141516// Hello Bob, Alice, Grace!public class Main &#123; public static void main(String[] args) &#123; String[] names = &#123;&quot;Bob&quot;, &quot;Alice&quot;, &quot;Grace&quot;&#125;; var sb = new StringBuilder(); sb.append(&quot;Hello &quot;); for (String name : names) &#123; sb.append(name).append(&quot;, &quot;); &#125; // 注意去掉最后的&quot;, &quot;: sb.delete(sb.length() - 2, sb.length()); sb.append(&quot;!&quot;); System.out.println(sb.toString()); &#125;&#125; 类似用分隔符拼接数组的需求很常见，所以Java标准库还提供了一个StringJoiner来干这个事： 123456789101112import java.util.StringJoiner;public class Main &#123; public static void main(String[] args) &#123; String[] names = &#123;&quot;Bob&quot;, &quot;Alice&quot;, &quot;Grace&quot;&#125;; var sj = new StringJoiner(&quot;, &quot;); for (String name : names) &#123; sj.add(name); &#125; System.out.println(sj.toString()); &#125;&#125; 慢着！用StringJoiner的结果少了前面的&quot;Hello &quot;和结尾的&quot;!&quot;！遇到这种情况，需要给StringJoiner指定“开头”和“结尾”： 123456789101112import java.util.StringJoiner;public class Main &#123; public static void main(String[] args) &#123; String[] names = &#123;&quot;Bob&quot;, &quot;Alice&quot;, &quot;Grace&quot;&#125;; var sj = new StringJoiner(&quot;, &quot;, &quot;Hello &quot;, &quot;!&quot;); for (String name : names) &#123; sj.add(name); &#125; System.out.println(sj.toString()); &#125;&#125; String.join()String还提供了一个静态方法join()，这个方法在内部使用了StringJoiner来拼接字符串，在不需要指定“开头”和“结尾”的时候，用String.join()更方便： 12String[] names = &#123;&quot;Bob&quot;, &quot;Alice&quot;, &quot;Grace&quot;&#125;;var s = String.join(&quot;, &quot;, names); 练习请使用StringJoiner构造一个SELECT语句： 123456789101112131415161718192021public class Main &#123; public static void main(String[] args) &#123; String[] fields = &#123;&quot;name&quot;, &quot;position&quot;, &quot;salary&quot;&#125;; String table = &quot;employee&quot;; String select = buildSelectSql(table, fields); System.out.println(select); System.out.println(&quot;SELECT name, position, salary FROM employee&quot;.equals(select) ? &quot;测试成功&quot; : &quot;测试失败&quot;); &#125; static String buildSelectSql(String table, String[] fields) &#123; var sj = new StringJoiner(&quot;, &quot;, &quot;SELECT &quot;, &quot; FROM &quot; + table); for (String field : fields) &#123; sj.add(field); &#125; return sj.toString(); &#125;&#125; 小结用指定分隔符拼接字符串数组时，使用StringJoiner或者String.join()更方便； 用StringJoiner拼接字符串时，还可以额外附加一个“开头”和“结尾”。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"02-面向对象编程","slug":"Java/02-面向对象编程","permalink":"http://example.com/categories/Java/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"name":"--02-Java核心类","slug":"Java/02-面向对象编程/02-Java核心类","permalink":"http://example.com/categories/Java/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/02-Java%E6%A0%B8%E5%BF%83%E7%B1%BB/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java-02-02-02-StringBuilder","slug":"liaoxuefeng/02-面向对象编程/02-Java核心类/02-StringBuilder","date":"2020-08-04T18:00:00.000Z","updated":"2020-08-15T16:54:54.638Z","comments":true,"path":"2020/08/05/liaoxuefeng/02-面向对象编程/02-Java核心类/02-StringBuilder/","link":"","permalink":"http://example.com/2020/08/05/liaoxuefeng/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/02-Java%E6%A0%B8%E5%BF%83%E7%B1%BB/02-StringBuilder/","excerpt":"","text":"Java编译器对String做了特殊处理，使得我们可以直接用+拼接字符串。 考察下面的循环代码： 1234String s = &quot;&quot;;for (int i = 0; i &lt; 1000; i++) &#123; s = s + &quot;,&quot; + i;&#125; 虽然可以直接拼接字符串，但是，在循环中，每次循环都会创建新的字符串对象，然后扔掉旧的字符串。这样，绝大部分字符串都是临时对象，不但浪费内存，还会影响GC效率。 为了能高效拼接字符串，Java标准库提供了StringBuilder，它是一个可变对象，可以预分配缓冲区，这样，往StringBuilder中新增字符时，不会创建新的临时对象： 123456StringBuilder sb = new StringBuilder(1024);for (int i = 0; i &lt; 1000; i++) &#123; sb.append(&#x27;,&#x27;); sb.append(i);&#125;String s = sb.toString(); StringBuilder还可以进行链式操作： 123456789101112// 链式操作public class Main &#123; public static void main(String[] args) &#123; var sb = new StringBuilder(1024); sb.append(&quot;Mr &quot;) .append(&quot;Bob&quot;) .append(&quot;!&quot;) .insert(0, &quot;Hello, &quot;); System.out.println(sb.toString()); &#125;&#125; 如果我们查看StringBuilder的源码，可以发现，进行链式操作的关键是，定义的append()方法会返回this，这样，就可以不断调用自身的其他方法。 仿照StringBuilder，我们也可以设计支持链式操作的类。例如，一个可以不断增加的计数器： 123456789101112131415161718192021222324252627282930// 链式操作public class Main &#123; public static void main(String[] args) &#123; Adder adder = new Adder(); adder.add(3) .add(5) .inc() .add(10); System.out.println(adder.value()); &#125;&#125;class Adder &#123; private int sum = 0; public Adder add(int n) &#123; sum += n; return this; &#125; public Adder inc() &#123; sum ++; return this; &#125; public int value() &#123; return sum; &#125;&#125; 注意：对于普通的字符串+操作，并不需要我们将其改写为StringBuilder，因为Java编译器在编译时就自动把多个连续的+操作编码为StringConcatFactory的操作。在运行期，StringConcatFactory会自动把字符串连接操作优化为数组复制或者StringBuilder操作。 你可能还听说过StringBuffer，这是Java早期的一个StringBuilder的线程安全版本，它通过同步来保证多个线程操作StringBuffer也是安全的，但是同步会带来执行速度的下降。 StringBuilder和StringBuffer接口完全相同，现在完全没有必要使用StringBuffer。 练习请使用StringBuilder构造一个INSERT语句： 1234567891011121314151617181920212223242526272829303132public class Main &#123; public static void main(String[] args) &#123; String[] fields = &#123;&quot;name&quot;, &quot;position&quot;, &quot;salary&quot;&#125;; String table = &quot;employee&quot;; String insert = buildInsertSql(table, fields); System.out.println(insert); System.out.println( &quot;INSERT INTO employee (name, position, salary) VALUES (?, ?, ?)&quot;.equals(insert) ? &quot;测试成功&quot; : &quot;测试失败&quot;); &#125; static String buildInsertSql(String table, String[] fields) &#123; String sqlBegin = &quot;INSERT INTO &quot; + table + &quot; (&quot;; String sqlMiddle = &quot;) VALUES (&quot;; String sqlEnd = &quot;)&quot;; StringBuilder sbBegin = new StringBuilder(sqlBegin); StringBuilder sbMiddle = new StringBuilder(sqlMiddle); for (int i = 0; i &lt; fields.length; i++) &#123; sbBegin.append(fields[i]); sbMiddle.append(&quot;?&quot;); if (i != fields.length - 1) &#123; sbBegin.append(&quot;, &quot;); sbMiddle.append(&quot;, &quot;); &#125; &#125; return sbBegin.toString() + sbMiddle.toString() + sqlEnd; &#125;&#125; 小结StringBuilder是可变对象，用来高效拼接字符串； StringBuilder可以支持链式操作，实现链式操作的关键是返回实例本身； StringBuffer是StringBuilder的线程安全版本，现在很少使用。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"02-面向对象编程","slug":"Java/02-面向对象编程","permalink":"http://example.com/categories/Java/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"name":"--02-Java核心类","slug":"Java/02-面向对象编程/02-Java核心类","permalink":"http://example.com/categories/Java/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/02-Java%E6%A0%B8%E5%BF%83%E7%B1%BB/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java-02-02-01-字符串和编码","slug":"liaoxuefeng/02-面向对象编程/02-Java核心类/01-字符串和编码","date":"2020-08-04T17:00:00.000Z","updated":"2020-08-15T16:54:20.185Z","comments":true,"path":"2020/08/05/liaoxuefeng/02-面向对象编程/02-Java核心类/01-字符串和编码/","link":"","permalink":"http://example.com/2020/08/05/liaoxuefeng/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/02-Java%E6%A0%B8%E5%BF%83%E7%B1%BB/01-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E7%BC%96%E7%A0%81/","excerpt":"","text":"String在Java中，String是一个引用类型，它本身也是一个class。但是，Java编译器对String有特殊处理，即可以直接用&quot;...&quot;来表示一个字符串： 1String s1 = &quot;Hello!&quot;; 实际上字符串在String内部是通过一个char[]数组表示的，因此，按下面的写法也是可以的： 1String s2 = new String(new char[] &#123;&#x27;H&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;!&#x27;&#125;); 因为String太常用了，所以Java提供了&quot;...&quot;这种字符串字面量表示方法。 Java字符串的一个重要特点就是字符串不可变。这种不可变性是通过内部的private final char[]字段，以及没有任何修改char[]的方法实现的。 我们来看一个例子： 12345678910// Stringpublic class Main &#123; public static void main(String[] args) &#123; String s = &quot;Hello&quot;; System.out.println(s); s = s.toUpperCase(); System.out.println(s); &#125;&#125; 根据上面代码的输出，试解释字符串内容是否改变。 字符串比较当我们想要比较两个字符串是否相同时，要特别注意，我们实际上是想比较字符串的内容是否相同。必须使用equals()方法而不能用==。 我们看下面的例子： 12345678910// Stringpublic class Main &#123; public static void main(String[] args) &#123; String s1 = &quot;hello&quot;; String s2 = &quot;hello&quot;; System.out.println(s1 == s2); System.out.println(s1.equals(s2)); &#125;&#125; 从表面上看，两个字符串用==和equals()比较都为true，但实际上那只是Java编译器在编译期，会自动把所有相同的字符串当作一个对象放入常量池，自然s1和s2的引用就是相同的。 所以，这种==比较返回true纯属巧合。换一种写法，==比较就会失败： 12345678910// Stringpublic class Main &#123; public static void main(String[] args) &#123; String s1 = &quot;hello&quot;; String s2 = &quot;HELLO&quot;.toLowerCase(); System.out.println(s1 == s2); System.out.println(s1.equals(s2)); &#125;&#125; 结论：两个字符串比较，必须总是使用equals()方法。 要忽略大小写比较，使用equalsIgnoreCase()方法。 String类还提供了多种方法来搜索子串、提取子串。常用的方法有： 12// 是否包含子串:&quot;Hello&quot;.contains(&quot;ll&quot;); // true 注意到contains()方法的参数是CharSequence而不是String，因为CharSequence是String的父类。 搜索子串的更多的例子： 1234&quot;Hello&quot;.indexOf(&quot;l&quot;); // 2&quot;Hello&quot;.lastIndexOf(&quot;l&quot;); // 3&quot;Hello&quot;.startsWith(&quot;He&quot;); // true&quot;Hello&quot;.endsWith(&quot;lo&quot;); // true 提取子串的例子： 12&quot;Hello&quot;.substring(2); // &quot;llo&quot;&quot;Hello&quot;.substring(2, 4); &quot;ll&quot; 注意索引号是从0开始的。 去除首尾空白字符使用trim()方法可以移除字符串首尾空白字符。空白字符包括空格，\\t，\\r，\\n： 1&quot; \\tHello\\r\\n &quot;.trim(); // &quot;Hello&quot; 注意：trim()并没有改变字符串的内容，而是返回了一个新字符串。 另一个strip()方法也可以移除字符串首尾空白字符。它和trim()不同的是，类似中文的空格字符\\u3000也会被移除： 123&quot;\\u3000Hello\\u3000&quot;.strip(); // &quot;Hello&quot;&quot; Hello &quot;.stripLeading(); // &quot;Hello &quot;&quot; Hello &quot;.stripTrailing(); // &quot; Hello&quot; String还提供了isEmpty()和isBlank()来判断字符串是否为空和空白字符串： 1234&quot;&quot;.isEmpty(); // true，因为字符串长度为0&quot; &quot;.isEmpty(); // false，因为字符串长度不为0&quot; \\n&quot;.isBlank(); // true，因为只包含空白字符&quot; Hello &quot;.isBlank(); // false，因为包含非空白字符 替换子串要在字符串中替换子串，有两种方法。一种是根据字符或字符串替换： 123String s = &quot;hello&quot;;s.replace(&#x27;l&#x27;, &#x27;w&#x27;); // &quot;hewwo&quot;，所有字符&#x27;l&#x27;被替换为&#x27;w&#x27;s.replace(&quot;ll&quot;, &quot;~~&quot;); // &quot;he~~o&quot;，所有子串&quot;ll&quot;被替换为&quot;~~&quot; 另一种是通过正则表达式替换： 12String s = &quot;A,,B;C ,D&quot;;s.replaceAll(&quot;[\\\\,\\\\;\\\\s]+&quot;, &quot;,&quot;); // &quot;A,B,C,D&quot; 上面的代码通过正则表达式，把匹配的子串统一替换为&quot;,&quot;。关于正则表达式的用法我们会在后面详细讲解。 分割字符串要分割字符串，使用split()方法，并且传入的也是正则表达式： 12String s = &quot;A,B,C,D&quot;;String[] ss = s.split(&quot;\\\\,&quot;); // &#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;&#125; 拼接字符串拼接字符串使用静态方法join()，它用指定的字符串连接字符串数组： 12String[] arr = &#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;&#125;;String s = String.join(&quot;***&quot;, arr); // &quot;A***B***C&quot; 格式化字符串字符串提供了formatted()方法和format()静态方法，可以传入其他参数，替换占位符，然后生成新的字符串： 123456789// Stringpublic class Main &#123; public static void main(String[] args) &#123; String s = &quot;Hi %s, your score is %d!&quot;; System.out.println(s.formatted(&quot;Alice&quot;, 80)); System.out.println(String.format(&quot;Hi %s, your score is %.2f!&quot;, &quot;Bob&quot;, 100.0)); &#125;&#125; 有几个占位符，后面就传入几个参数。参数类型要和占位符一致。我们经常用这个方法来格式化信息。常用的占位符有： %s：显示字符串； %d：显示整数； %x：显示十六进制整数； %f：显示浮点数。 占位符还可以带格式，例如%.2f表示显示两位小数。如果你不确定用啥占位符，那就始终用%s，因为%s可以显示任何数据类型。要查看完整的格式化语法，请参考JDK文档。 类型转换要把任意基本类型或引用类型转换为字符串，可以使用静态方法valueOf()。这是一个重载方法，编译器会根据参数自动选择合适的方法： 1234String.valueOf(123); // &quot;123&quot;String.valueOf(45.67); // &quot;45.67&quot;String.valueOf(true); // &quot;true&quot;String.valueOf(new Object()); // 类似java.lang.Object@636be97c 要把字符串转换为其他类型，就需要根据情况。例如，把字符串转换为int类型： 12int n1 = Integer.parseInt(&quot;123&quot;); // 123int n2 = Integer.parseInt(&quot;ff&quot;, 16); // 按十六进制转换，255 把字符串转换为boolean类型： 12boolean b1 = Boolean.parseBoolean(&quot;true&quot;); // trueboolean b2 = Boolean.parseBoolean(&quot;FALSE&quot;); // false 要特别注意，Integer有个getInteger(String)方法，它不是将字符串转换为int，而是把该字符串对应的系统变量转换为Integer： 1Integer.getInteger(&quot;java.version&quot;); // 版本号，11 转换为char[]String和char[]类型可以互相转换，方法是： 12char[] cs = &quot;Hello&quot;.toCharArray(); // String -&gt; char[]String s = new String(cs); // char[] -&gt; String 如果修改了char[]数组，String并不会改变： 1234567891011// String &lt;-&gt; char[]public class Main &#123; public static void main(String[] args) &#123; char[] cs = &quot;Hello&quot;.toCharArray(); String s = new String(cs); System.out.println(s); cs[0] = &#x27;X&#x27;; System.out.println(s); &#125;&#125; 这是因为通过new String(char[])创建新的String实例时，它并不会直接引用传入的char[]数组，而是会复制一份，所以，修改外部的char[]数组不会影响String实例内部的char[]数组，因为这是两个不同的数组。 从String的不变性设计可以看出，如果传入的对象有可能改变，我们需要复制而不是直接引用。 例如，下面的代码设计了一个Score类保存一组学生的成绩： 123456789101112131415161718192021222324// int[]import java.util.Arrays;public class Main &#123; public static void main(String[] args) &#123; int[] scores = new int[] &#123; 88, 77, 51, 66 &#125;; Score s = new Score(scores); s.printScores(); scores[2] = 99; s.printScores(); &#125;&#125;class Score &#123; private int[] scores; public Score(int[] scores) &#123; this.scores = scores; &#125; public void printScores() &#123; System.out.println(Arrays.toString(scores)); &#125;&#125; 观察两次输出，由于Score内部直接引用了外部传入的int[]数组，这会造成外部代码对int[]数组的修改，影响到Score类的字段。如果外部代码不可信，这就会造成安全隐患。 请修复Score的构造方法，使得外部代码对数组的修改不影响Score实例的int[]字段。 字符编码在早期的计算机系统中，为了给字符编码，美国国家标准学会（American National Standard Institute：ANSI）制定了一套英文字母、数字和常用符号的编码，它占用一个字节，编码范围从0到127，最高位始终为0，称为ASCII编码。例如，字符&#39;A&#39;的编码是0x41，字符&#39;1&#39;的编码是0x31。 如果要把汉字也纳入计算机编码，很显然一个字节是不够的。GB2312标准使用两个字节表示一个汉字，其中第一个字节的最高位始终为1，以便和ASCII编码区分开。例如，汉字&#39;中&#39;的GB2312编码是0xd6d0。 类似的，日文有Shift_JIS编码，韩文有EUC-KR编码，这些编码因为标准不统一，同时使用，就会产生冲突。 为了统一全球所有语言的编码，全球统一码联盟发布了Unicode编码，它把世界上主要语言都纳入同一个编码，这样，中文、日文、韩文和其他语言就不会冲突。 Unicode编码需要两个或者更多字节表示，我们可以比较中英文字符在ASCII、GB2312和Unicode的编码： 英文字符&#39;A&#39;的ASCII编码和Unicode编码： 123456 ┌────┐ASCII: │ 41 │ └────┘ ┌────┬────┐Unicode: │ 00 │ 41 │ └────┴────┘ 英文字符的Unicode编码就是简单地在前面添加一个00字节。 中文字符&#39;中&#39;的GB2312编码和Unicode编码： 123456 ┌────┬────┐GB2312: │ d6 │ d0 │ └────┴────┘ ┌────┬────┐Unicode: │ 4e │ 2d │ └────┴────┘ 那我们经常使用的UTF-8又是什么编码呢？因为英文字符的Unicode编码高字节总是00，包含大量英文的文本会浪费空间，所以，出现了UTF-8编码，它是一种变长编码，用来把固定长度的Unicode编码变成1～4字节的变长编码。通过UTF-8编码，英文字符&#39;A&#39;的UTF-8编码变为0x41，正好和ASCII码一致，而中文&#39;中&#39;的UTF-8编码为3字节0xe4b8ad。 UTF-8编码的另一个好处是容错能力强。如果传输过程中某些字符出错，不会影响后续字符，因为UTF-8编码依靠高字节位来确定一个字符究竟是几个字节，它经常用来作为传输编码。 在Java中，char类型实际上就是两个字节的Unicode编码。如果我们要手动把字符串转换成其他编码，可以这样做： 1234byte[] b1 = &quot;Hello&quot;.getBytes(); // 按系统默认编码转换，不推荐byte[] b2 = &quot;Hello&quot;.getBytes(&quot;UTF-8&quot;); // 按UTF-8编码转换byte[] b2 = &quot;Hello&quot;.getBytes(&quot;GBK&quot;); // 按GBK编码转换byte[] b3 = &quot;Hello&quot;.getBytes(StandardCharsets.UTF_8); // 按UTF-8编码转换 注意：转换编码后，就不再是char类型，而是byte类型表示的数组。 如果要把已知编码的byte[]转换为String，可以这样做： 123byte[] b = ...String s1 = new String(b, &quot;GBK&quot;); // 按GBK转换String s2 = new String(b, StandardCharsets.UTF_8); // 按UTF-8转换 始终牢记：Java的String和char在内存中总是以Unicode编码表示。 延伸阅读对于不同版本的JDK，String类在内存中有不同的优化方式。具体来说，早期JDK版本的String总是以char[]存储，它的定义如下： 12345public final class String &#123; private final char[] value; private final int offset; private final int count;&#125; 而较新的JDK版本的String则以byte[]存储：如果String仅包含ASCII字符，则每个byte存储一个字符，否则，每两个byte存储一个字符，这样做的目的是为了节省内存，因为大量的长度较短的String通常仅包含ASCII字符： 123public final class String &#123; private final byte[] value; private final byte coder; // 0 = LATIN1, 1 = UTF16 对于使用者来说，String内部的优化不影响任何已有代码，因为它的public方法签名是不变的。 小结 Java字符串String是不可变对象； 字符串操作不改变原字符串内容，而是返回新字符串； 常用的字符串操作：提取子串、查找、替换、大小写转换等； Java使用Unicode编码表示String和char； 转换编码就是将String和byte[]转换，需要指定编码； 转换为byte[]时，始终优先考虑UTF-8编码。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"02-面向对象编程","slug":"Java/02-面向对象编程","permalink":"http://example.com/categories/Java/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"name":"--02-Java核心类","slug":"Java/02-面向对象编程/02-Java核心类","permalink":"http://example.com/categories/Java/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/02-Java%E6%A0%B8%E5%BF%83%E7%B1%BB/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java-02-01-12-模块","slug":"liaoxuefeng/02-面向对象编程/01-面向对象基础/12-模块","date":"2020-08-04T05:00:00.000Z","updated":"2020-08-15T16:52:49.672Z","comments":true,"path":"2020/08/04/liaoxuefeng/02-面向对象编程/01-面向对象基础/12-模块/","link":"","permalink":"http://example.com/2020/08/04/liaoxuefeng/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/01-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/12-%E6%A8%A1%E5%9D%97/","excerpt":"","text":"从Java 9开始，JDK又引入了模块（Module）。 什么是模块？这要从Java 9之前的版本说起。 我们知道，.class文件是JVM看到的最小可执行文件，而一个大型程序需要编写很多Class，并生成一堆.class文件，很不便于管理，所以，jar文件就是class文件的容器。 在Java 9之前，一个大型Java程序会生成自己的jar文件，同时引用依赖的第三方jar文件，而JVM自带的Java标准库，实际上也是以jar文件形式存放的，这个文件叫rt.jar，一共有60多M。 如果是自己开发的程序，除了一个自己的app.jar以外，还需要一堆第三方的jar包，运行一个Java程序，一般来说，命令行写这样： 1java -cp app.jar:a.jar:b.jar:c.jar com.liaoxuefeng.sample.Main 注意：JVM自带的标准库rt.jar不要写到classpath中，写了反而会干扰JVM的正常运行。 如果漏写了某个运行时需要用到的jar，那么在运行期极有可能抛出ClassNotFoundException。 所以，jar只是用于存放class的容器，它并不关心class之间的依赖。 从Java 9开始引入的模块，主要是为了解决“依赖”这个问题。如果a.jar必须依赖另一个b.jar才能运行，那我们应该给a.jar加点说明啥的，让程序在编译和运行的时候能自动定位到b.jar，这种自带“依赖关系”的class容器就是模块。 为了表明Java模块化的决心，从Java 9开始，原有的Java标准库已经由一个单一巨大的rt.jar分拆成了几十个模块，这些模块以.jmod扩展名标识，可以在$JAVA_HOME/jmods目录下找到它们： java.base.jmod java.compiler.jmod java.datatransfer.jmod java.desktop.jmod … 这些.jmod文件每一个都是一个模块，模块名就是文件名。例如：模块java.base对应的文件就是java.base.jmod。模块之间的依赖关系已经被写入到模块内的module-info.class文件了。所有的模块都直接或间接地依赖java.base模块，只有java.base模块不依赖任何模块，它可以被看作是“根模块”，好比所有的类都是从Object直接或间接继承而来。 把一堆class封装为jar仅仅是一个打包的过程，而把一堆class封装为模块则不但需要打包，还需要写入依赖关系，并且还可以包含二进制代码（通常是JNI扩展）。此外，模块支持多版本，即在同一个模块中可以为不同的JVM提供不同的版本。 编写模块那么，我们应该如何编写模块呢？还是以具体的例子来说。首先，创建模块和原有的创建Java项目是完全一样的，以oop-module工程为例，它的目录结构如下： 12345678910oop-module├── bin├── build.sh└── src ├── com │ └── itranswarp │ └── sample │ ├── Greeting.java │ └── Main.java └── module-info.java 其中，bin目录存放编译后的class文件，src目录存放源码，按包名的目录结构存放，仅仅在src目录下多了一个module-info.java这个文件，这就是模块的描述文件。在这个模块中，它长这样： 1234module hello.world &#123; requires java.base; // 可不写，任何模块都会自动引入java.base requires java.xml;&#125; 其中，module是关键字，后面的hello.world是模块的名称，它的命名规范与包一致。花括号的requires xxx;表示这个模块需要引用的其他模块名。除了java.base可以被自动引入外，这里我们引入了一个java.xml的模块。 当我们使用模块声明了依赖关系后，才能使用引入的模块。例如，Main.java代码如下： 1234567891011package com.itranswarp.sample;// 必须引入java.xml模块后才能使用其中的类:import javax.xml.XMLConstants;public class Main &#123; public static void main(String[] args) &#123; Greeting g = new Greeting(); System.out.println(g.hello(XMLConstants.XML_NS_PREFIX)); &#125;&#125; 如果把requires java.xml;从module-info.java中去掉，编译将报错。可见，模块的重要作用就是声明依赖关系。 下面，我们用JDK提供的命令行工具来编译并创建模块。 首先，我们把工作目录切换到oop-module，在当前目录下编译所有的.java文件，并存放到bin目录下，命令如下： 1$ javac -d bin src/module-info.java src/com/itranswarp/sample/*.java 如果编译成功，现在项目结构如下： 123456789101112131415oop-module├── bin│ ├── com│ │ └── itranswarp│ │ └── sample│ │ ├── Greeting.class│ │ └── Main.class│ └── module-info.class└── src ├── com │ └── itranswarp │ └── sample │ ├── Greeting.java │ └── Main.java └── module-info.java 注意到src目录下的module-info.java被编译到bin目录下的module-info.class。 下一步，我们需要把bin目录下的所有class文件先打包成jar，在打包的时候，注意传入--main-class参数，让这个jar包能自己定位main方法所在的类： 1$ jar --create --file hello.jar --main-class com.itranswarp.sample.Main -C bin . 现在我们就在当前目录下得到了hello.jar这个jar包，它和普通jar包并无区别，可以直接使用命令java -jar hello.jar来运行它。但是我们的目标是创建模块，所以，继续使用JDK自带的jmod命令把一个jar包转换成模块： 1$ jmod create --class-path hello.jar hello.jmod 于是，在当前目录下我们又得到了hello.jmod这个模块文件，这就是最后打包出来的传说中的模块！ 运行模块要运行一个jar，我们使用java -jar xxx.jar命令。要运行一个模块，我们只需要指定模块名。试试： 1$ java --module-path hello.jmod --module hello.world 结果是一个错误： 12Error occurred during initialization of boot layerjava.lang.module.FindException: JMOD format not supported at execution time: hello.jmod 原因是.jmod不能被放入--module-path中。换成.jar就没问题了： 12$ java --module-path hello.jar --module hello.worldHello, xml! 那我们辛辛苦苦创建的hello.jmod有什么用？答案是我们可以用它来打包JRE。 打包JRE前面讲了，为了支持模块化，Java 9首先带头把自己的一个巨大无比的rt.jar拆成了几十个.jmod模块，原因就是，运行Java程序的时候，实际上我们用到的JDK模块，并没有那么多。不需要的模块，完全可以删除。 过去发布一个Java应用程序，要运行它，必须下载一个完整的JRE，再运行jar包。而完整的JRE块头很大，有100多M。怎么给JRE瘦身呢？ 现在，JRE自身的标准库已经分拆成了模块，只需要带上程序用到的模块，其他的模块就可以被裁剪掉。怎么裁剪JRE呢？并不是说把系统安装的JRE给删掉部分模块，而是“复制”一份JRE，但只带上用到的模块。为此，JDK提供了jlink命令来干这件事。命令如下： 1$ jlink --module-path hello.jmod --add-modules java.base,java.xml,hello.world --output jre/ 我们在--module-path参数指定了我们自己的模块hello.jmod，然后，在--add-modules参数中指定了我们用到的3个模块java.base、java.xml和hello.world，用,分隔。最后，在--output参数指定输出目录。 现在，在当前目录下，我们可以找到jre目录，这是一个完整的并且带有我们自己hello.jmod模块的JRE。试试直接运行这个JRE： 12$ jre/bin/java --module hello.worldHello, xml! 要分发我们自己的Java应用程序，只需要把这个jre目录打个包给对方发过去，对方直接运行上述命令即可，既不用下载安装JDK，也不用知道如何配置我们自己的模块，极大地方便了分发和部署。 访问权限前面我们讲过，Java的class访问权限分为public、protected、private和默认的包访问权限。引入模块后，这些访问权限的规则就要稍微做些调整。 确切地说，class的这些访问权限只在一个模块内有效，模块和模块之间，例如，a模块要访问b模块的某个class，必要条件是b模块明确地导出了可以访问的包。 举个例子：我们编写的模块hello.world用到了模块java.xml的一个类javax.xml.XMLConstants，我们之所以能直接使用这个类，是因为模块java.xml的module-info.java中声明了若干导出： 123456module java.xml &#123; exports java.xml; exports javax.xml.catalog; exports javax.xml.datatype; ...&#125; 只有它声明的导出的包，外部代码才被允许访问。换句话说，如果外部代码想要访问我们的hello.world模块中的com.itranswarp.sample.Greeting类，我们必须将其导出： 123456module hello.world &#123; exports com.itranswarp.sample; requires java.base; requires java.xml;&#125; 因此，模块进一步隔离了代码的访问权限。 练习请下载并练习如何打包模块和JRE。 小结Java 9引入的模块目的是为了管理依赖； 使用模块可以按需打包JRE； 使用模块对类的访问权限有了进一步限制。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"02-面向对象编程","slug":"Java/02-面向对象编程","permalink":"http://example.com/categories/Java/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"name":"--01-面向对象基础","slug":"Java/02-面向对象编程/01-面向对象基础","permalink":"http://example.com/categories/Java/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/01-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java-02-01-11-classpath和jar","slug":"liaoxuefeng/02-面向对象编程/01-面向对象基础/11-classpath和jar","date":"2020-08-04T04:00:00.000Z","updated":"2020-08-15T16:52:25.125Z","comments":true,"path":"2020/08/04/liaoxuefeng/02-面向对象编程/01-面向对象基础/11-classpath和jar/","link":"","permalink":"http://example.com/2020/08/04/liaoxuefeng/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/01-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/11-classpath%E5%92%8Cjar/","excerpt":"","text":"在Java中，我们经常听到classpath这个东西。网上有很多关于“如何设置classpath”的文章，但大部分设置都不靠谱。 到底什么是classpath？ classpath是JVM用到的一个环境变量，它用来指示JVM如何搜索class。 因为Java是编译型语言，源码文件是.java，而编译后的.class文件才是真正可以被JVM执行的字节码。因此，JVM需要知道，如果要加载一个abc.xyz.Hello的类，应该去哪搜索对应的Hello.class文件。 所以，classpath就是一组目录的集合，它设置的搜索路径与操作系统相关。例如，在Windows系统上，用;分隔，带空格的目录用&quot;&quot;括起来，可能长这样： 1C:\\work\\project1\\bin;C:\\shared;&quot;D:\\My Documents\\project1\\bin&quot; 在Linux系统上，用:分隔，可能长这样： 1&#x2F;usr&#x2F;shared:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;home&#x2F;liaoxuefeng&#x2F;bin 现在我们假设classpath是.;C:\\work\\project1\\bin;C:\\shared，当JVM在加载abc.xyz.Hello这个类时，会依次查找： &lt;当前目录&gt;\\abc\\xyz\\Hello.class C:\\work\\project1\\bin\\abc\\xyz\\Hello.class C:\\shared\\abc\\xyz\\Hello.class 注意到.代表当前目录。如果JVM在某个路径下找到了对应的class文件，就不再往后继续搜索。如果所有路径下都没有找到，就报错。 classpath的设定方法有两种： 在系统环境变量中设置classpath环境变量，不推荐； 在启动JVM时设置classpath变量，推荐。 我们强烈不推荐在系统环境变量中设置classpath，那样会污染整个系统环境。在启动JVM时设置classpath才是推荐的做法。实际上就是给java命令传入-classpath或-cp参数： 1java -classpath .;C:\\work\\project1\\bin;C:\\shared abc.xyz.Hello 或者使用-cp的简写： 1java -cp .;C:\\work\\project1\\bin;C:\\shared abc.xyz.Hello 没有设置系统环境变量，也没有传入-cp参数，那么JVM默认的classpath为.，即当前目录： 1java abc.xyz.Hello 上述命令告诉JVM只在当前目录搜索Hello.class。 在IDE中运行Java程序，IDE自动传入的-cp参数是当前工程的bin目录和引入的jar包。 通常，我们在自己编写的class中，会引用Java核心库的class，例如，String、ArrayList等。这些class应该上哪去找？ 有很多“如何设置classpath”的文章会告诉你把JVM自带的rt.jar放入classpath，但事实上，根本不需要告诉JVM如何去Java核心库查找class，JVM怎么可能笨到连自己的核心库在哪都不知道？ 不要把任何Java核心库添加到classpath中！JVM根本不依赖classpath加载核心库！ 更好的做法是，不要设置classpath！默认的当前目录.对于绝大多数情况都够用了。 jar包如果有很多.class文件，散落在各层目录中，肯定不便于管理。如果能把目录打一个包，变成一个文件，就方便多了。 jar包就是用来干这个事的，它可以把package组织的目录层级，以及各个目录下的所有文件（包括.class文件和其他文件）都打成一个jar文件，这样一来，无论是备份，还是发给客户，就简单多了。 jar包实际上就是一个zip格式的压缩文件，而jar包相当于目录。如果我们要执行一个jar包的class，就可以把jar包放到classpath中： 1java -cp .&#x2F;hello.jar abc.xyz.Hello 这样JVM会自动在hello.jar文件里去搜索某个类。 那么问题来了：如何创建jar包？ 因为jar包就是zip包，所以，直接在资源管理器中，找到正确的目录，点击右键，在弹出的快捷菜单中选择“发送到”，“压缩(zipped)文件夹”，就制作了一个zip文件。然后，把后缀从.zip改为.jar，一个jar包就创建成功。 假设编译输出的目录结构是这样： 123456789package_sample└─ bin ├─ hong │ └─ Person.class │ ming │ └─ Person.class └─ mr └─ jun └─ Arrays.class 这里需要特别注意的是，jar包里的第一层目录，不能是bin，而应该是hong、ming、mr。如果在Windows的资源管理器中看，应该长这样： 如果长这样： 说明打包打得有问题，JVM仍然无法从jar包中查找正确的class，原因是hong.Person必须按hong/Person.class存放，而不是bin/hong/Person.class。 jar包还可以包含一个特殊的/META-INF/MANIFEST.MF文件，MANIFEST.MF是纯文本，可以指定Main-Class和其它信息。JVM会自动读取这个MANIFEST.MF文件，如果存在Main-Class，我们就不必在命令行指定启动的类名，而是用更方便的命令： 1java -jar hello.jar jar包还可以包含其它jar包，这个时候，就需要在MANIFEST.MF文件里配置classpath了。 在大型项目中，不可能手动编写MANIFEST.MF文件，再手动创建zip包。Java社区提供了大量的开源构建工具，例如Maven，可以非常方便地创建jar包。 小结JVM通过环境变量classpath决定搜索class的路径和顺序； 不推荐设置系统环境变量classpath，始终建议通过-cp命令传入； jar包相当于目录，可以包含很多.class文件，方便下载和使用； MANIFEST.MF文件可以提供jar包的信息，如Main-Class，这样可以直接运行jar包。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"02-面向对象编程","slug":"Java/02-面向对象编程","permalink":"http://example.com/categories/Java/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"name":"--01-面向对象基础","slug":"Java/02-面向对象编程/01-面向对象基础","permalink":"http://example.com/categories/Java/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/01-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java-02-01-10-作用域","slug":"liaoxuefeng/02-面向对象编程/01-面向对象基础/10-作用域","date":"2020-08-04T03:00:00.000Z","updated":"2020-08-15T16:51:41.742Z","comments":true,"path":"2020/08/04/liaoxuefeng/02-面向对象编程/01-面向对象基础/10-作用域/","link":"","permalink":"http://example.com/2020/08/04/liaoxuefeng/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/01-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/10-%E4%BD%9C%E7%94%A8%E5%9F%9F/","excerpt":"","text":"在Java中，我们经常看到public、protected、private这些修饰符。在Java中，这些修饰符可以用来限定访问作用域。 public定义为public的class、interface可以被其他任何类访问： 123456package abc;public class Hello &#123; public void hi() &#123; &#125;&#125; 上面的Hello是public，因此，可以被其他包的类访问： 12345678package xyz;class Main &#123; void foo() &#123; // Main可以访问Hello Hello h = new Hello(); &#125;&#125; 定义为public的field、method可以被其他类访问，前提是首先有访问class的权限： 123456package abc;public class Hello &#123; public void hi() &#123; &#125;&#125; 上面的hi()方法是public，可以被其他类调用，前提是首先要能访问Hello类： 12345678package xyz;class Main &#123; void foo() &#123; Hello h = new Hello(); h.hi(); &#125;&#125; private定义为private的field、method无法被其他类访问： 1234567891011package abc;public class Hello &#123; // 不能被其他类调用: private void hi() &#123; &#125; public void hello() &#123; this.hi(); &#125;&#125; 实际上，确切地说，private访问权限被限定在class的内部，而且与方法声明顺序无关。推荐把private方法放到后面，因为public方法定义了类对外提供的功能，阅读代码的时候，应该先关注public方法： 12345678910package abc;public class Hello &#123; public void hello() &#123; this.hi(); &#125; private void hi() &#123; &#125;&#125; 由于Java支持嵌套类，如果一个类内部还定义了嵌套类，那么，嵌套类拥有访问private的权限： 1234567891011121314151617181920// privatepublic class Main &#123; public static void main(String[] args) &#123; Inner i = new Inner(); i.hi(); &#125; // private方法: private static void hello() &#123; System.out.println(&quot;private hello!&quot;); &#125; // 静态内部类: static class Inner &#123; public void hi() &#123; Main.hello(); &#125; &#125;&#125; 定义在一个class内部的class称为嵌套类（nested class），Java支持好几种嵌套类。 protectedprotected作用于继承关系。定义为protected的字段和方法可以被子类访问，以及子类的子类： 1234567package abc;public class Hello &#123; // protected方法: protected void hi() &#123; &#125;&#125; 上面的protected方法可以被继承的类访问： 123456789package xyz;class Main extends Hello &#123; void foo() &#123; Hello h = new Hello(); // 可以访问protected方法: h.hi(); &#125;&#125; package最后，包作用域是指一个类允许访问同一个package的没有public、private修饰的class，以及没有public、protected、private修饰的字段和方法。 1234567package abc;// package权限的类:class Hello &#123; // package权限的方法: void hi() &#123; &#125;&#125; 只要在同一个包，就可以访问package权限的class、field和method： 12345678910package abc;class Main &#123; void foo() &#123; // 可以访问package权限的类: Hello h = new Hello(); // 可以调用package权限的方法: h.hi(); &#125;&#125; 注意，包名必须完全一致，包没有父子关系，com.apache和com.apache.abc是不同的包。 局部变量在方法内部定义的变量称为局部变量，局部变量作用域从变量声明处开始到对应的块结束。方法参数也是局部变量。 1234567891011121314package abc;public class Hello &#123; void hi(String name) &#123; // ① String s = name.toLowerCase(); // ② int len = s.length(); // ③ if (len &lt; 10) &#123; // ④ int p = 10 - len; // ⑤ for (int i=0; i&lt;10; i++) &#123; // ⑥ System.out.println(); // ⑦ &#125; // ⑧ &#125; // ⑨ &#125; // ⑩&#125; 我们观察上面的hi()方法代码： 方法参数name是局部变量，它的作用域是整个方法，即①～⑩； 变量s的作用域是定义处到方法结束，即②～⑩； 变量len的作用域是定义处到方法结束，即③～⑩； 变量p的作用域是定义处到if块结束，即⑤～⑨； 变量i的作用域是for循环，即⑥～⑧。 使用局部变量时，应该尽可能把局部变量的作用域缩小，尽可能延后声明局部变量。 finalJava还提供了一个final修饰符。final与访问权限不冲突，它有很多作用。 用final修饰class可以阻止被继承： 123456789package abc;// 无法被继承:public final class Hello &#123; private int n = 0; protected void hi(int t) &#123; long i = t; &#125;&#125; 用final修饰method可以阻止被子类覆写： 1234567package abc;public class Hello &#123; // 无法被覆写: protected final void hi() &#123; &#125;&#125; 用final修饰field可以阻止被重新赋值： 12345678package abc;public class Hello &#123; private final int n = 0; protected void hi() &#123; this.n = 1; // error! &#125;&#125; 用final修饰局部变量可以阻止被重新赋值： 1234567package abc;public class Hello &#123; protected void hi(final int t) &#123; t = 1; // error! &#125;&#125; 最佳实践如果不确定是否需要public，就不声明为public，即尽可能少地暴露对外的字段和方法。 把方法定义为package权限有助于测试，因为测试类和被测试类只要位于同一个package，测试代码就可以访问被测试类的package权限方法。 一个.java文件只能包含一个public类，但可以包含多个非public类。如果有public类，文件名必须和public类的名字相同。 小结Java内建的访问权限包括public、protected、private和package权限； Java在方法内部定义的变量是局部变量，局部变量的作用域从变量声明开始，到一个块结束； final修饰符不是访问权限，它可以修饰class、field和method； 一个.java文件只能包含一个public类，但可以包含多个非public类。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"02-面向对象编程","slug":"Java/02-面向对象编程","permalink":"http://example.com/categories/Java/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"name":"--01-面向对象基础","slug":"Java/02-面向对象编程/01-面向对象基础","permalink":"http://example.com/categories/Java/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/01-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java-02-01-09-包","slug":"liaoxuefeng/02-面向对象编程/01-面向对象基础/09-包","date":"2020-08-04T02:00:00.000Z","updated":"2020-08-15T16:51:07.329Z","comments":true,"path":"2020/08/04/liaoxuefeng/02-面向对象编程/01-面向对象基础/09-包/","link":"","permalink":"http://example.com/2020/08/04/liaoxuefeng/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/01-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/09-%E5%8C%85/","excerpt":"","text":"在前面的代码中，我们把类和接口命名为Person、Student、Hello等简单名字。 在现实中，如果小明写了一个Person类，小红也写了一个Person类，现在，小白既想用小明的Person，也想用小红的Person，怎么办？ 如果小军写了一个Arrays类，恰好JDK也自带了一个Arrays类，如何解决类名冲突？ 在Java中，我们使用package来解决名字冲突。 Java定义了一种名字空间，称之为包：package。一个类总是属于某个包，类名（比如Person）只是一个简写，真正的完整类名是包名.类名。 例如： 小明的Person类存放在包ming下面，因此，完整类名是ming.Person； 小红的Person类存放在包hong下面，因此，完整类名是hong.Person； 小军的Arrays类存放在包mr.jun下面，因此，完整类名是mr.jun.Arrays； JDK的Arrays类存放在包java.util下面，因此，完整类名是java.util.Arrays。 在定义class的时候，我们需要在第一行声明这个class属于哪个包。 小明的Person.java文件： 1234package ming; // 申明包名mingpublic class Person &#123;&#125; 小军的Arrays.java文件： 1234package mr.jun; // 申明包名mr.junpublic class Arrays &#123;&#125; 在Java虚拟机执行的时候，JVM只看完整类名，因此，只要包名不同，类就不同。 包可以是多层结构，用.隔开。例如：java.util。 要特别注意：包没有父子关系。java.util和java.util.zip是不同的包，两者没有任何继承关系。 没有定义包名的class，它使用的是默认包，非常容易引起名字冲突，因此，不推荐不写包名的做法。 我们还需要按照包结构把上面的Java文件组织起来。假设以package_sample作为根目录，src作为源码目录，那么所有文件结构就是： 123456789package_sample└─ src ├─ hong │ └─ Person.java │ ming │ └─ Person.java └─ mr └─ jun └─ Arrays.java 即所有Java文件对应的目录层次要和包的层次一致。 编译后的.class文件也需要按照包结构存放。如果使用IDE，把编译后的.class文件放到bin目录下，那么，编译的文件结构就是： 123456789package_sample└─ bin ├─ hong │ └─ Person.class │ ming │ └─ Person.class └─ mr └─ jun └─ Arrays.class 编译的命令相对比较复杂，我们需要在src目录下执行javac命令： 1javac -d ..&#x2F;bin ming&#x2F;Person.java hong&#x2F;Person.java mr&#x2F;jun&#x2F;Arrays.java 在IDE中，会自动根据包结构编译所有Java源码，所以不必担心使用命令行编译的复杂命令。 包作用域位于同一个包的类，可以访问包作用域的字段和方法。不用public、protected、private修饰的字段和方法就是包作用域。例如，Person类定义在hello包下面： 12345678package hello;public class Person &#123; // 包作用域: void hello() &#123; System.out.println(&quot;Hello!&quot;); &#125;&#125; Main类也定义在hello包下面： 12345678package hello;public class Main &#123; public static void main(String[] args) &#123; Person p = new Person(); p.hello(); // 可以调用，因为Main和Person在同一个包 &#125;&#125; import在一个class中，我们总会引用其他的class。例如，小明的ming.Person类，如果要引用小军的mr.jun.Arrays类，他有三种写法： 第一种，直接写出完整类名，例如： 12345678// Person.javapackage ming;public class Person &#123; public void run() &#123; mr.jun.Arrays arrays = new mr.jun.Arrays(); &#125;&#125; 很显然，每次写完整类名比较痛苦。 因此，第二种写法是用import语句，导入小军的Arrays，然后写简单类名： 1234567891011// Person.javapackage ming;// 导入完整类名:import mr.jun.Arrays;public class Person &#123; public void run() &#123; Arrays arrays = new Arrays(); &#125;&#125; 在写import的时候，可以使用*，表示把这个包下面的所有class都导入进来（但不包括子包的class）： 1234567891011// Person.javapackage ming;// 导入mr.jun包的所有class:import mr.jun.*;public class Person &#123; public void run() &#123; Arrays arrays = new Arrays(); &#125;&#125; 我们一般不推荐这种写法，因为在导入了多个包后，很难看出Arrays类属于哪个包。 还有一种import static的语法，它可以导入一个类的静态字段和静态方法： 1234567891011package main;// 导入System类的所有静态字段和静态方法:import static java.lang.System.*;public class Main &#123; public static void main(String[] args) &#123; // 相当于调用System.out.println(…) out.println(&quot;Hello, world!&quot;); &#125;&#125; import static很少使用。 Java编译器最终编译出的.class文件只使用完整类名，因此，在代码中，当编译器遇到一个class名称时： 如果是完整类名，就直接根据完整类名查找这个class； 如果是简单类名，按下面的顺序依次查找： 查找当前package是否存在这个class； 查找import的包是否包含这个class； 查找java.lang包是否包含这个class。 如果按照上面的规则还无法确定类名，则编译报错。 我们来看一个例子： 1234567891011121314// Main.javapackage test;import java.text.Format;public class Main &#123; public static void main(String[] args) &#123; java.util.List list; // ok，使用完整类名 -&gt; java.util.List Format format = null; // ok，使用import的类 -&gt; java.text.Format String s = &quot;hi&quot;; // ok，使用java.lang包的String -&gt; java.lang.String System.out.println(s); // ok，使用java.lang包的System -&gt; java.lang.System MessageFormat mf = null; // 编译错误：无法找到MessageFormat: MessageFormat cannot be resolved to a type &#125;&#125; 因此，编写class的时候，编译器会自动帮我们做两个import动作： 默认自动import当前package的其他class； 默认自动import java.lang.*。 注意：自动导入的是java.lang包，但类似java.lang.reflect这些包仍需要手动导入。 如果有两个class名称相同，例如，mr.jun.Arrays和java.util.Arrays，那么只能import其中一个，另一个必须写完整类名。 最佳实践为了避免名字冲突，我们需要确定唯一的包名。推荐的做法是使用倒置的域名来确保唯一性。例如： org.apache org.apache.commons.log com.liaoxuefeng.sample 子包就可以根据功能自行命名。 要注意不要和java.lang包的类重名，即自己的类不要使用这些名字： String System Runtime … 要注意也不要和JDK常用类重名： java.util.List java.text.Format java.math.BigInteger … 练习请按如下包结构创建工程项目： 12345678oop-package└── src └── com └── itranswarp ├── sample │ └── Main.java └── world └── Person.java 123456789101112package com.itranswarp.sample;import com.itranswarp.world.Person;public class Main &#123; public static void main(String[] args) &#123; Person p1 = new Person(&quot;小明&quot;); System.out.println(p1.hello()); &#125;&#125; 1234567891011121314package com.itranswarp.world;public class Person &#123; String name; public Person(String name) &#123; this.name = name; &#125; public String hello() &#123; return &quot;Hello, &quot; + this.name; &#125;&#125; 小结Java内建的package机制是为了避免class命名冲突； JDK的核心类使用java.lang包，编译器会自动导入； JDK的其它常用类定义在java.util.*，java.math.*，java.text.*，……； 包名推荐使用倒置的域名，例如org.apache。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"02-面向对象编程","slug":"Java/02-面向对象编程","permalink":"http://example.com/categories/Java/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"name":"--01-面向对象基础","slug":"Java/02-面向对象编程/01-面向对象基础","permalink":"http://example.com/categories/Java/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/01-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java-02-01-08-静态字段和静态方法","slug":"liaoxuefeng/02-面向对象编程/01-面向对象基础/08-静态字段和静态方法","date":"2020-08-04T01:00:00.000Z","updated":"2020-08-15T16:50:42.868Z","comments":true,"path":"2020/08/04/liaoxuefeng/02-面向对象编程/01-面向对象基础/08-静态字段和静态方法/","link":"","permalink":"http://example.com/2020/08/04/liaoxuefeng/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/01-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/08-%E9%9D%99%E6%80%81%E5%AD%97%E6%AE%B5%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/","excerpt":"","text":"在一个class中定义的字段，我们称之为实例字段。实例字段的特点是，每个实例都有独立的字段，各个实例的同名字段互不影响。 还有一种字段，是用static修饰的字段，称为静态字段：static field。 实例字段在每个实例中都有自己的一个独立“空间”，但是静态字段只有一个共享“空间”，所有实例都会共享该字段。举个例子： 123456class Person &#123; public String name; public int age; // 定义静态字段number: public static int number;&#125; 我们来看看下面的代码： 123456789101112131415161718192021222324// static fieldpublic class Main &#123; public static void main(String[] args) &#123; Person ming = new Person(&quot;Xiao Ming&quot;, 12); Person hong = new Person(&quot;Xiao Hong&quot;, 15); ming.number = 88; System.out.println(hong.number); hong.number = 99; System.out.println(ming.number); &#125;&#125;class Person &#123; public String name; public int age; public static int number; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125;&#125; 对于静态字段，无论修改哪个实例的静态字段，效果都是一样的：所有实例的静态字段都被修改了，原因是静态字段并不属于实例： 12345678910111213141516 ┌──────────────────┐ming ──&gt;│Person instance │ ├──────────────────┤ │name &#x3D; &quot;Xiao Ming&quot;│ │age &#x3D; 12 │ │number ───────────┼──┐ ┌─────────────┐ └──────────────────┘ │ │Person class │ │ ├─────────────┤ ├───&gt;│number &#x3D; 99 │ ┌──────────────────┐ │ └─────────────┘hong ──&gt;│Person instance │ │ ├──────────────────┤ │ │name &#x3D; &quot;Xiao Hong&quot;│ │ │age &#x3D; 15 │ │ │number ───────────┼──┘ └──────────────────┘ 虽然实例可以访问静态字段，但是它们指向的其实都是Person class的静态字段。所以，所有实例共享一个静态字段。 因此，不推荐用实例变量.静态字段去访问静态字段，因为在Java程序中，实例对象并没有静态字段。在代码中，实例对象能访问静态字段只是因为编译器可以根据实例类型自动转换为类名.静态字段来访问静态对象。 推荐用类名来访问静态字段。可以把静态字段理解为描述class本身的字段（非实例字段）。对于上面的代码，更好的写法是： 12Person.number = 99;System.out.println(Person.number); 静态方法有静态字段，就有静态方法。用static修饰的方法称为静态方法。 调用实例方法必须通过一个实例变量，而调用静态方法则不需要实例变量，通过类名就可以调用。静态方法类似其它编程语言的函数。例如： 12345678910111213141516// static methodpublic class Main &#123; public static void main(String[] args) &#123; Person.setNumber(99); System.out.println(Person.number); &#125;&#125;class Person &#123; public static int number; public static void setNumber(int value) &#123; number = value; &#125;&#125; 因为静态方法属于class而不属于实例，因此，静态方法内部，无法访问this变量，也无法访问实例字段，它只能访问静态字段。 通过实例变量也可以调用静态方法，但这只是编译器自动帮我们把实例改写成类名而已。 通常情况下，通过实例变量访问静态字段和静态方法，会得到一个编译警告。 静态方法经常用于工具类。例如： Arrays.sort() Math.random() 静态方法也经常用于辅助方法。注意到Java程序的入口main()也是静态方法。 接口的静态字段因为interface是一个纯抽象类，所以它不能定义实例字段。但是，interface是可以有静态字段的，并且静态字段必须为final类型： 1234public interface Person &#123; public static final int MALE = 1; public static final int FEMALE = 2;&#125; 实际上，因为interface的字段只能是public static final类型，所以我们可以把这些修饰符都去掉，上述代码可以简写为： 12345public interface Person &#123; // 编译器会自动加上public statc final: int MALE = 1; int FEMALE = 2;&#125; 编译器会自动把该字段变为public static final类型。 练习给Person类增加一个静态字段count和静态方法getCount，统计实例创建的个数。 12345678910111213public class Main &#123; public static void main(String[] args) &#123; // TODO: 给Person类增加一个静态字段count和静态方法getCount，统计实例的个数 Person p1 = new Person(&quot;小明&quot;); System.out.println(Person.getCount()); // 1 Person p2 = new Person(&quot;小红&quot;); System.out.println(Person.getCount()); // 2 Person p3 = new Person(&quot;小军&quot;); System.out.println(Person.getCount()); // 3 &#125;&#125; 123456789101112131415public class Person &#123; public static int count = 0; String name; public Person(String name) &#123; this.name = name; count++; &#125; public static int getCount() &#123; return count; &#125;&#125; 小结 静态字段属于所有实例“共享”的字段，实际上是属于class的字段； 调用静态方法不需要实例，无法访问this，但可以访问静态字段和其他静态方法； 静态方法常用于工具类和辅助方法。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"02-面向对象编程","slug":"Java/02-面向对象编程","permalink":"http://example.com/categories/Java/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"name":"--01-面向对象基础","slug":"Java/02-面向对象编程/01-面向对象基础","permalink":"http://example.com/categories/Java/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/01-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java-02-01-07-接口","slug":"liaoxuefeng/02-面向对象编程/01-面向对象基础/07-接口","date":"2020-08-04T00:00:00.000Z","updated":"2020-08-15T16:50:10.681Z","comments":true,"path":"2020/08/04/liaoxuefeng/02-面向对象编程/01-面向对象基础/07-接口/","link":"","permalink":"http://example.com/2020/08/04/liaoxuefeng/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/01-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/07-%E6%8E%A5%E5%8F%A3/","excerpt":"","text":"在抽象类中，抽象方法本质上是定义接口规范：即规定高层类的接口，从而保证所有子类都有相同的接口实现，这样，多态就能发挥出威力。 如果一个抽象类没有字段，所有方法全部都是抽象方法： 1234abstract class Person &#123; public abstract void run(); public abstract String getName();&#125; 就可以把该抽象类改写为接口：interface。 在Java中，使用interface可以声明一个接口： 1234interface Person &#123; void run(); String getName();&#125; 所谓interface，就是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有。因为接口定义的所有方法默认都是public abstract的，所以这两个修饰符不需要写出来（写不写效果都一样）。 当一个具体的class去实现一个interface时，需要使用implements关键字。举个例子： 1234567891011121314151617class Student implements Person &#123; private String name; public Student(String name) &#123; this.name = name; &#125; @Override public void run() &#123; System.out.println(this.name + &quot; run&quot;); &#125; @Override public String getName() &#123; return this.name; &#125;&#125; 我们知道，在Java中，一个类只能继承自另一个类，不能从多个类继承。但是，一个类可以实现多个interface，例如： 123class Student implements Person, Hello &#123; // 实现了两个interface ...&#125; 术语注意区分术语： Java的接口特指interface的定义，表示一个接口类型和一组方法签名，而编程接口泛指接口规范，如方法签名，数据格式，网络协议等。 抽象类和接口的对比如下： abstract class interface 继承 只能extends一个class 可以implements多个interface 字段 可以定义实例字段 不能定义实例字段 抽象方法 可以定义抽象方法 可以定义抽象方法 非抽象方法 可以定义非抽象方法 可以定义default方法 接口继承一个interface可以继承自另一个interface。interface继承自interface使用extends，它相当于扩展了接口的方法。例如： 12345678interface Hello &#123; void hello();&#125;interface Person extends Hello &#123; void run(); String getName();&#125; 此时，Person接口继承自Hello接口，因此，Person接口现在实际上有3个抽象方法签名，其中一个来自继承的Hello接口。 继承关系合理设计interface和abstract class的继承关系，可以充分复用代码。一般来说，公共逻辑适合放在abstract class中，具体逻辑放到各个子类，而接口层次代表抽象程度。可以参考Java的集合类定义的一组接口、抽象类以及具体子类的继承关系： 12345678910111213141516171819202122┌───────────────┐│ Iterable │└───────────────┘ ▲ ┌───────────────────┐ │ │ Object │┌───────────────┐ └───────────────────┘│ Collection │ ▲└───────────────┘ │ ▲ ▲ ┌───────────────────┐ │ └──────────│AbstractCollection │┌───────────────┐ └───────────────────┘│ List │ ▲└───────────────┘ │ ▲ ┌───────────────────┐ └──────────│ AbstractList │ └───────────────────┘ ▲ ▲ │ │ │ │ ┌────────────┐ ┌────────────┐ │ ArrayList │ │ LinkedList │ └────────────┘ └────────────┘ 在使用的时候，实例化的对象永远只能是某个具体的子类，但总是通过接口去引用它，因为接口比抽象类更抽象： 123List list = new ArrayList(); // 用List接口引用具体子类的实例Collection coll = list; // 向上转型为Collection接口Iterable it = coll; // 向上转型为Iterable接口 default方法在接口中，可以定义default方法。例如，把Person接口的run()方法改为default方法： 123456789101112131415161718192021222324252627// interfacepublic class Main &#123; public static void main(String[] args) &#123; Person p = new Student(&quot;Xiao Ming&quot;); p.run(); &#125;&#125;interface Person &#123; String getName(); default void run() &#123; System.out.println(getName() + &quot; run&quot;); &#125;&#125;class Student implements Person &#123; private String name; public Student(String name) &#123; this.name = name; &#125; public String getName() &#123; return this.name; &#125;&#125; 实现类可以不必覆写default方法。default方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是default方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。 default方法和抽象类的普通方法是有所不同的。因为interface没有字段，default方法无法访问字段，而抽象类的普通方法可以访问实例字段。 练习用接口给一个有工资收入和稿费收入的小伙伴算税。 1234567891011121314/** * 定义接口Income */public interface Income &#123; double getIncome(); double getTaxRate(); default double getTax() &#123; return getIncome() * getTaxRate(); &#125;&#125; 123456789101112131415161718192021/** * 定义基础收入类 */public class BasicIncome implements Income &#123; private double income; public BasicIncome(double income) &#123; this.income = income; &#125; @Override public double getIncome() &#123; return this.income; &#125; @Override public double getTaxRate() &#123; return 0.1; &#125;&#125; 12345678910111213141516171819202122232425/** * 定义薪水类 */public class SalaryIncome implements Income &#123; private double income; public SalaryIncome(double income) &#123; this.income = income; &#125; @Override public double getIncome() &#123; if (income &lt;= 5000) &#123; return 0; &#125; return (this.income - 5000); &#125; @Override public double getTaxRate() &#123; return 0.2; &#125;&#125; 12345678910111213141516171819202122/** * 定义稿费收入 */public class RoyaltyIncome implements Income &#123; private double income; public RoyaltyIncome(double income) &#123; this.income = income; &#125; @Override public double getIncome() &#123; return this.income; &#125; @Override public double getTaxRate() &#123; return 0.2; &#125;&#125; 123456789101112131415161718192021/** * 创建实例 */public class Main &#123; public static void main(String[] args) &#123; // TODO: 用接口给一个有工资收入和稿费收入的小伙伴算税: Income[] incomes = new Income[]&#123; new BasicIncome(3000), new SalaryIncome(7500), new RoyaltyIncome(12000) &#125;; double total = 0; // TODO: for (Income income : incomes) &#123; total += income.getTax(); &#125; System.out.println(total); &#125;&#125; 小结Java的接口（interface）定义了纯抽象规范，一个类可以实现多个接口； 接口也是数据类型，适用于向上转型和向下转型； 接口的所有方法都是抽象方法，接口不能定义实例字段； 接口可以定义default方法（JDK&gt;=1.8）。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"02-面向对象编程","slug":"Java/02-面向对象编程","permalink":"http://example.com/categories/Java/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"name":"--01-面向对象基础","slug":"Java/02-面向对象编程/01-面向对象基础","permalink":"http://example.com/categories/Java/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/01-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java-02-01-06-抽象类","slug":"liaoxuefeng/02-面向对象编程/01-面向对象基础/06-抽象类","date":"2020-08-03T23:00:00.000Z","updated":"2020-08-15T16:49:35.643Z","comments":true,"path":"2020/08/04/liaoxuefeng/02-面向对象编程/01-面向对象基础/06-抽象类/","link":"","permalink":"http://example.com/2020/08/04/liaoxuefeng/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/01-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/06-%E6%8A%BD%E8%B1%A1%E7%B1%BB/","excerpt":"","text":"由于多态的存在，每个子类都可以覆写父类的方法，例如： 12345678910111213class Person &#123; public void run() &#123; … &#125;&#125;class Student extends Person &#123; @Override public void run() &#123; … &#125;&#125;class Teacher extends Person &#123; @Override public void run() &#123; … &#125;&#125; 从Person类派生的Student和Teacher都可以覆写run()方法。 如果父类Person的run()方法没有实际意义，能否去掉方法的执行语句？ 123class Person &#123; public void run(); // Compile Error!&#125; 答案是不行，会导致编译错误，因为定义方法的时候，必须实现方法的语句。 能不能去掉父类的run()方法？ 答案还是不行，因为去掉父类的run()方法，就失去了多态的特性。例如，runTwice()就无法编译： 1234public void runTwice(Person p) &#123; p.run(); // Person没有run()方法，会导致编译错误 p.run();&#125; 如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么，可以把父类的方法声明为抽象方法： 123class Person &#123; public abstract void run();&#125; 把一个方法声明为abstract，表示它是一个抽象方法，本身没有实现任何方法语句。因为这个抽象方法本身是无法执行的，所以，Person类也无法被实例化。编译器会告诉我们，无法编译Person类，因为它包含抽象方法。 必须把Person类本身也声明为abstract，才能正确编译它： 123abstract class Person &#123; public abstract void run();&#125; 抽象类如果一个class定义了方法，但没有具体执行代码，这个方法就是抽象方法，抽象方法用abstract修饰。 因为无法执行抽象方法，因此这个类也必须申明为抽象类（abstract class）。 使用abstract修饰的类就是抽象类。我们无法实例化一个抽象类： 1Person p = new Person(); // 编译错误 无法实例化的抽象类有什么用？ 因为抽象类本身被设计成只能用于被继承，因此，抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错。因此，抽象方法实际上相当于定义了“规范”。 例如，Person类定义了抽象方法run()，那么，在实现子类Student的时候，就必须覆写run()方法： 12345678910111213141516171819// abstract classpublic class Main &#123; public static void main(String[] args) &#123; Person p = new Student(); p.run(); &#125;&#125;abstract class Person &#123; public abstract void run();&#125;class Student extends Person &#123; @Override public void run() &#123; System.out.println(&quot;Student.run&quot;); &#125;&#125; 面向抽象编程当我们定义了抽象类Person，以及具体的Student、Teacher子类的时候，我们可以通过抽象类Person类型去引用具体的子类的实例： 12Person s = new Student();Person t = new Teacher(); 这种引用抽象类的好处在于，我们对其进行方法调用，并不关心Person类型变量的具体子类型： 123// 不关心Person变量的具体子类型:s.run();t.run(); 同样的代码，如果引用的是一个新的子类，我们仍然不关心具体类型： 123// 同样不关心新的子类是如何实现run()方法的：Person e = new Employee();e.run(); 这种尽量引用高层类型，避免引用实际子类型的方式，称之为面向抽象编程。 面向抽象编程的本质就是： 上层代码只定义规范（例如：abstract class Person）； 不需要子类就可以实现业务逻辑（正常编译）； 具体的业务逻辑由不同的子类实现，调用者并不关心。 练习用抽象类给一个有工资收入和稿费收入的小伙伴算税。 1234567891011121314/** * 定义抽象类Income */public abstract class Income &#123; protected double income; public Income(double income) &#123; this.income = income; &#125; public abstract double getTax();&#125; 123456789101112131415public class SalaryIncome extends Income &#123; public SalaryIncome(double income) &#123; super(income); &#125; @Override public double getTax() &#123; if (income &lt;= 5000) &#123; return 0; &#125; return (income - 5000) * 0.2; &#125;&#125; 123456789101112131415/** * 稿费收入税率是20% */public class RoyaltyIncome extends Income &#123; public RoyaltyIncome(double income) &#123; super(income); &#125; @Override public double getTax() &#123; return income * 0.2; &#125;&#125; 12345678910111213141516171819202122public class Main &#123; public static void main(String[] args) &#123; // TODO: 用抽象类给一个有工资收入和稿费收入的小伙伴算税: Income[] incomes = new Income[]&#123; new Income(3000) &#123; @Override public double getTax() &#123; return income * 0.1; &#125; &#125;, new SalaryIncome(7500), new RoyaltyIncome(12000) &#125;; double total = 0; for (Income income : incomes) &#123; total += income.getTax(); &#125; System.out.println(total); &#125;&#125; 小结 通过abstract定义的方法是抽象方法，它只有定义，没有实现。抽象方法定义了子类必须实现的接口规范； 定义了抽象方法的class必须被定义为抽象类，从抽象类继承的子类必须实现抽象方法； 如果不实现抽象方法，则该子类仍是一个抽象类； 面向抽象编程使得调用者只关心抽象方法的定义，不关心子类的具体实现。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"02-面向对象编程","slug":"Java/02-面向对象编程","permalink":"http://example.com/categories/Java/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"name":"--01-面向对象基础","slug":"Java/02-面向对象编程/01-面向对象基础","permalink":"http://example.com/categories/Java/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/01-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java-02-01-05-多态","slug":"liaoxuefeng/02-面向对象编程/01-面向对象基础/05-多态","date":"2020-08-03T22:00:00.000Z","updated":"2020-08-15T16:45:54.038Z","comments":true,"path":"2020/08/04/liaoxuefeng/02-面向对象编程/01-面向对象基础/05-多态/","link":"","permalink":"http://example.com/2020/08/04/liaoxuefeng/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/01-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/05-%E5%A4%9A%E6%80%81/","excerpt":"","text":"在继承关系中，子类如果定义了一个与父类方法签名完全相同的方法，被称为覆写（Override）。 例如，在Person类中，我们定义了run()方法： 12345class Person &#123; public void run() &#123; System.out.println(&quot;Person.run&quot;); &#125;&#125; 在子类Student中，覆写这个run()方法： 123456class Student extends Person &#123; @Override public void run() &#123; System.out.println(&quot;Student.run&quot;); &#125;&#125; Override和Overload不同的是，如果方法签名不同，就是Overload，Overload方法是一个新方法；如果方法签名相同，并且返回值也相同，就是Override。 注意：方法名相同，方法参数相同，但方法返回值不同，也是不同的方法。在Java程序中，出现这种情况，编译器会报错。 12345678910class Person &#123; public void run() &#123; … &#125;&#125;class Student extends Person &#123; // 不是Override，因为参数不同: public void run(String s) &#123; … &#125; // 不是Override，因为返回值不同: public int run() &#123; … &#125;&#125; 加上@Override可以让编译器帮助检查是否进行了正确的覆写。希望进行覆写，但是不小心写错了方法签名，编译器会报错。 123456789101112131415// overridepublic class Main &#123; public static void main(String[] args) &#123; &#125;&#125;class Person &#123; public void run() &#123;&#125;&#125;public class Student extends Person &#123; @Override // Compile error! public void run(String s) &#123;&#125;&#125; 但是@Override不是必需的。 在上一节中，我们已经知道，引用变量的声明类型可能与其实际类型不符，例如： 1Person p = new Student(); 现在，我们考虑一种情况，如果子类覆写了父类的方法： 123456789101112131415161718192021// overridepublic class Main &#123; public static void main(String[] args) &#123; Person p = new Student(); p.run(); // 应该打印Person.run还是Student.run? &#125;&#125;class Person &#123; public void run() &#123; System.out.println(&quot;Person.run&quot;); &#125;&#125;class Student extends Person &#123; @Override public void run() &#123; System.out.println(&quot;Student.run&quot;); &#125;&#125; 那么，一个实际类型为Student，引用类型为Person的变量，调用其run()方法，调用的是Person还是Student的run()方法？ 运行一下上面的代码就可以知道，实际上调用的方法是Student的run()方法。因此可得出结论： Java的实例方法调用是基于运行时的实际类型的动态调用，而非变量的声明类型。 这个非常重要的特性在面向对象编程中称之为多态。它的英文拼写非常复杂：Polymorphic。 多态多态是指，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法。例如： 12Person p = new Student();p.run(); // 无法确定运行时究竟调用哪个run()方法 有童鞋会问，从上面的代码一看就明白，肯定调用的是Student的run()方法啊。 但是，假设我们编写这样一个方法： 1234public void runTwice(Person p) &#123; p.run(); p.run();&#125; 它传入的参数类型是Person，我们是无法知道传入的参数实际类型究竟是Person，还是Student，还是Person的其他子类，因此，也无法确定调用的是不是Person类定义的run()方法。 所以，多态的特性就是，运行期才能动态决定调用的子类方法。对某个类型调用某个方法，执行的实际方法可能是某个子类的覆写方法。这种不确定性的方法调用，究竟有什么作用？ 我们还是来举栗子。 假设我们定义一种收入，需要给它报税，那么先定义一个Income类： 123456class Income &#123; protected double income; public double getTax() &#123; return income * 0.1; // 税率10% &#125;&#125; 对于工资收入，可以减去一个基数，那么我们可以从Income派生出SalaryIncome，并覆写getTax()： 123456789class Salary extends Income &#123; @Override public double getTax() &#123; if (income &lt;= 5000) &#123; return 0; &#125; return (income - 5000) * 0.2; &#125;&#125; 如果你享受国务院特殊津贴，那么按照规定，可以全部免税： 123456class StateCouncilSpecialAllowance extends Income &#123; @Override public double getTax() &#123; return 0; &#125;&#125; 现在，我们要编写一个报税的财务软件，对于一个人的所有收入进行报税，可以这么写： 1234567public double totalTax(Income... incomes) &#123; double total = 0; for (Income income: incomes) &#123; total = total + income.getTax(); &#125; return total;&#125; 来试一下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// Polymorphicpublic class Main &#123; public static void main(String[] args) &#123; // 给一个有普通收入、工资收入和享受国务院特殊津贴的小伙伴算税: Income[] incomes = new Income[] &#123; new Income(3000), new Salary(7500), new StateCouncilSpecialAllowance(15000) &#125;; System.out.println(totalTax(incomes)); &#125; public static double totalTax(Income... incomes) &#123; double total = 0; for (Income income: incomes) &#123; total = total + income.getTax(); &#125; return total; &#125;&#125;class Income &#123; protected double income; public Income(double income) &#123; this.income = income; &#125; public double getTax() &#123; return income * 0.1; // 税率10% &#125;&#125;class Salary extends Income &#123; public Salary(double income) &#123; super(income); &#125; @Override public double getTax() &#123; if (income &lt;= 5000) &#123; return 0; &#125; return (income - 5000) * 0.2; &#125;&#125;class StateCouncilSpecialAllowance extends Income &#123; public StateCouncilSpecialAllowance(double income) &#123; super(income); &#125; @Override public double getTax() &#123; return 0; &#125;&#125; 观察totalTax()方法：利用多态，totalTax()方法只需要和Income打交道，它完全不需要知道Salary和StateCouncilSpecialAllowance的存在，就可以正确计算出总的税。如果我们要新增一种稿费收入，只需要从Income派生，然后正确覆写getTax()方法就可以。把新的类型传入totalTax()，不需要修改任何代码。 可见，多态具有一个非常强大的功能，就是允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码。 覆写Object方法因为所有的class最终都继承自Object，而Object定义了几个重要的方法： toString()：把instance输出为String； equals()：判断两个instance是否逻辑相等； hashCode()：计算一个instance的哈希值。 在必要的情况下，我们可以覆写Object的这几个方法。例如： 1234567891011121314151617181920212223242526class Person &#123; ... // 显示更有意义的字符串: @Override public String toString() &#123; return &quot;Person:name=&quot; + name; &#125; // 比较是否相等: @Override public boolean equals(Object o) &#123; // 当且仅当o为Person类型: if (o instanceof Person) &#123; Person p = (Person) o; // 并且name字段相同时，返回true: return this.name.equals(p.name); &#125; return false; &#125; // 计算hash: @Override public int hashCode() &#123; return this.name.hashCode(); &#125;&#125; 调用super在子类的覆写方法中，如果要调用父类的被覆写的方法，可以通过super来调用。例如： 1234567891011121314class Person &#123; protected String name; public String hello() &#123; return &quot;Hello, &quot; + name; &#125;&#125;Student extends Person &#123; @Override public String hello() &#123; // 调用父类的hello()方法: return super.hello() + &quot;!&quot;; &#125;&#125; final继承可以允许子类覆写父类的方法。如果一个父类不允许子类对它的某个方法进行覆写，可以把该方法标记为final。用final修饰的方法不能被Override： 12345678910111213class Person &#123; protected String name; public final String hello() &#123; return &quot;Hello, &quot; + name; &#125;&#125;Student extends Person &#123; // compile error: 不允许覆写 @Override public String hello() &#123; &#125;&#125; 如果一个类不希望任何其他类继承自它，那么可以把这个类本身标记为final。用final修饰的类不能被继承： 1234567final class Person &#123; protected String name;&#125;// compile error: 不允许继承自PersonStudent extends Person &#123;&#125; 对于一个类的实例字段，同样可以用final修饰。用final修饰的字段在初始化后不能被修改。例如： 123class Person &#123; public final String name = &quot;Unamed&quot;;&#125; 对final字段重新赋值会报错： 12Person p = new Person();p.name = &quot;New Name&quot;; // compile error! 可以在构造方法中初始化final字段： 123456class Person &#123; public final String name; public Person(String name) &#123; this.name = name; &#125;&#125; 这种方法更为常用，因为可以保证实例一旦创建，其final字段就不可修改。 练习给一个有工资收入和稿费收入的小伙伴算税。 12345678910111213public class Income &#123; protected double income; public Income(double income) &#123; this.income = income; &#125; public double getTax() &#123; return income * 0.1; // 税率10% &#125;&#125; 1234567891011121314public class SalaryIncome extends Income &#123; public SalaryIncome(double income) &#123; super(income); &#125; @Override public double getTax() &#123; if (income &lt;= 5000) &#123; return 0; &#125; return (income - 5000) * 0.2; &#125;&#125; 123456789101112131415/** * 稿费收入税率是20% */public class RoyaltyIncome extends Income &#123; public RoyaltyIncome(double income) &#123; super(income); &#125; @Override public double getTax() &#123; return income * 0.2; &#125;&#125; 1234567891011121314151617181920public class Main &#123; public static void main(String[] args) &#123; // TODO: 给一个有工资收入和稿费收入的小伙伴算税: Income[] incomes = new Income[] &#123; new Income(3000), new SalaryIncome(7500), new RoyaltyIncome(12000) &#125;; System.out.println(totalTax(incomes)); &#125; public static double totalTax(Income... incomes)&#123; double total = 0; for(Income income : incomes)&#123; total += income.getTax(); &#125; return total; &#125;&#125; 小结 子类可以覆写父类的方法（Override），覆写在子类中改变了父类方法的行为； Java的方法调用总是作用于运行期对象的实际类型，这种行为称为多态； final修饰符有多种作用： final修饰的方法可以阻止被覆写； final修饰的class可以阻止被继承； final修饰的field必须在创建对象时初始化，随后不可修改。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"02-面向对象编程","slug":"Java/02-面向对象编程","permalink":"http://example.com/categories/Java/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"name":"--01-面向对象基础","slug":"Java/02-面向对象编程/01-面向对象基础","permalink":"http://example.com/categories/Java/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/01-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java-02-01-04-继承","slug":"liaoxuefeng/02-面向对象编程/01-面向对象基础/04-继承","date":"2020-08-03T21:00:00.000Z","updated":"2020-08-15T16:45:25.957Z","comments":true,"path":"2020/08/04/liaoxuefeng/02-面向对象编程/01-面向对象基础/04-继承/","link":"","permalink":"http://example.com/2020/08/04/liaoxuefeng/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/01-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/04-%E7%BB%A7%E6%89%BF/","excerpt":"","text":"在前面的章节中，我们已经定义了Person类： 123456789class Person &#123; private String name; private int age; public String getName() &#123;...&#125; public void setName(String name) &#123;...&#125; public int getAge() &#123;...&#125; public void setAge(int age) &#123;...&#125;&#125; 现在，假设需要定义一个Student类，字段如下： 123456789101112class Student &#123; private String name; private int age; private int score; public String getName() &#123;...&#125; public void setName(String name) &#123;...&#125; public int getAge() &#123;...&#125; public void setAge(int age) &#123;...&#125; public int getScore() &#123; … &#125; public void setScore(int score) &#123; … &#125;&#125; 仔细观察，发现Student类包含了Person类已有的字段和方法，只是多出了一个score字段和相应的getScore()、setScore()方法。 能不能在Student中不要写重复的代码？ 这个时候，继承就派上用场了。 继承是面向对象编程中非常强大的一种机制，它首先可以复用代码。当我们让Student从Person继承时，Student就获得了Person的所有功能，我们只需要为Student编写新增的功能。 Java使用extends关键字来实现继承： 123456789101112131415161718class Person &#123; private String name; private int age; public String getName() &#123;...&#125; public void setName(String name) &#123;...&#125; public int getAge() &#123;...&#125; public void setAge(int age) &#123;...&#125;&#125;class Student extends Person &#123; // 不要重复name和age字段/方法, // 只需要定义新增score字段/方法: private int score; public int getScore() &#123; … &#125; public void setScore(int score) &#123; … &#125;&#125; 可见，通过继承，Student只需要编写额外的功能，不再需要重复代码。 注意：子类自动获得了父类的所有字段，严禁定义与父类重名的字段！ 在OOP的术语中，我们把Person称为超类（super class），父类（parent class），基类（base class），把Student称为子类（subclass），扩展类（extended class）。 继承树注意到我们在定义Person的时候，没有写extends。在Java中，没有明确写extends的类，编译器会自动加上extends Object。所以，任何类，除了Object，都会继承自某个类。下图是Person、Student的继承树： 12345678910111213┌───────────┐│ Object │└───────────┘ ▲ │┌───────────┐│ Person │└───────────┘ ▲ │┌───────────┐│ Student │└───────────┘ Java只允许一个class继承自一个类，因此，一个类有且仅有一个父类。只有Object特殊，它没有父类。 类似的，如果我们定义一个继承自Person的Teacher，它们的继承树关系如下： 1234567891011121314 ┌───────────┐ │ Object │ └───────────┘ ▲ │ ┌───────────┐ │ Person │ └───────────┘ ▲ ▲ │ │ │ │┌───────────┐ ┌───────────┐│ Student │ │ Teacher │└───────────┘ └───────────┘ protected继承有个特点，就是子类无法访问父类的private字段或者private方法。例如，Student类就无法访问Person类的name和age字段： 12345678910class Person &#123; private String name; private int age;&#125;class Student extends Person &#123; public String hello() &#123; return &quot;Hello, &quot; + name; // 编译错误：无法访问name字段 &#125;&#125; 这使得继承的作用被削弱了。为了让子类可以访问父类的字段，我们需要把private改为protected。用protected修饰的字段可以被子类访问： 12345678910class Person &#123; protected String name; protected int age;&#125;class Student extends Person &#123; public String hello() &#123; return &quot;Hello, &quot; + name; // OK! &#125;&#125; 因此，protected关键字可以把字段和方法的访问权限控制在继承树内部，一个protected字段和方法可以被其子类，以及子类的子类所访问，后面我们还会详细讲解。 supersuper关键字表示父类（超类）。子类引用父类的字段时，可以用super.fieldName。例如： 12345class Student extends Person &#123; public String hello() &#123; return &quot;Hello, &quot; + super.name; &#125;&#125; 实际上，这里使用super.name，或者this.name，或者name，效果都是一样的。编译器会自动定位到父类的name字段。 但是，在某些时候，就必须使用super。我们来看一个例子： 12345678910111213141516171819202122232425// superpublic class Main &#123; public static void main(String[] args) &#123; Student s = new Student(&quot;Xiao Ming&quot;, 12, 89); &#125;&#125;class Person &#123; protected String name; protected int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125;&#125;class Student extends Person &#123; protected int score; public Student(String name, int age, int score) &#123; this.score = score; &#125;&#125; 运行上面的代码，会得到一个编译错误，大意是在Student的构造方法中，无法调用Person的构造方法。 这是因为在Java中，任何class的构造方法，第一行语句必须是调用父类的构造方法。如果没有明确地调用父类的构造方法，编译器会帮我们自动加一句super();，所以，Student类的构造方法实际上是这样： 12345678class Student extends Person &#123; protected int score; public Student(String name, int age, int score) &#123; super(); // 自动调用父类的构造方法 this.score = score; &#125;&#125; 但是，Person类并没有无参数的构造方法，因此，编译失败。 解决方法是调用Person类存在的某个构造方法。例如： 12345678class Student extends Person &#123; protected int score; public Student(String name, int age, int score) &#123; super(name, age); // 调用父类的构造方法Person(String, int) this.score = score; &#125;&#125; 这样就可以正常编译了！ 因此我们得出结论：如果父类没有默认的构造方法，子类就必须显式调用super()并给出参数以便让编译器定位到父类的一个合适的构造方法。 这里还顺带引出了另一个问题：即子类不会继承任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的。 向上转型如果一个引用变量的类型是Student，那么它可以指向一个Student类型的实例： 1Student s = new Student(); 如果一个引用类型的变量是Person，那么它可以指向一个Person类型的实例： 1Person p = new Person(); 现在问题来了：如果Student是从Person继承下来的，那么，一个引用类型为Person的变量，能否指向Student类型的实例？ 1Person p = new Student(); // ??? 测试一下就可以发现，这种指向是允许的！ 这是因为Student继承自Person，因此，它拥有Person的全部功能。Person类型的变量，如果指向Student类型的实例，对它进行操作，是没有问题的！ 这种把一个子类类型安全地变为父类类型的赋值，被称为向上转型（upcasting）。 向上转型实际上是把一个子类型安全地变为更加抽象的父类型： 1234Student s = new Student();Person p = s; // upcasting, okObject o1 = p; // upcasting, okObject o2 = s; // upcasting, ok 注意到继承树是Student &gt; Person &gt; Object，所以，可以把Student类型转型为Person，或者更高层次的Object。 向下转型和向上转型相反，如果把一个父类类型强制转型为子类类型，就是向下转型（downcasting）。例如： 1234Person p1 = new Student(); // upcasting, okPerson p2 = new Person();Student s1 = (Student) p1; // okStudent s2 = (Student) p2; // runtime error! ClassCastException! 如果测试上面的代码，可以发现： Person类型p1实际指向Student实例，Person类型变量p2实际指向Person实例。在向下转型的时候，把p1转型为Student会成功，因为p1确实指向Student实例，把p2转型为Student会失败，因为p2的实际类型是Person，不能把父类变为子类，因为子类功能比父类多，多的功能无法凭空变出来。 因此，向下转型很可能会失败。失败的时候，Java虚拟机会报ClassCastException。 为了避免向下转型出错，Java提供了instanceof操作符，可以先判断一个实例究竟是不是某种类型： 12345678910Person p = new Person();System.out.println(p instanceof Person); // trueSystem.out.println(p instanceof Student); // falseStudent s = new Student();System.out.println(s instanceof Person); // trueSystem.out.println(s instanceof Student); // trueStudent n = null;System.out.println(n instanceof Student); // false instanceof实际上判断一个变量所指向的实例是否是指定类型，或者这个类型的子类。如果一个引用变量为null，那么对任何instanceof的判断都为false。 利用instanceof，在向下转型前可以先判断： 12345Person p = new Student();if (p instanceof Student) &#123; // 只有判断成功才会向下转型: Student s = (Student) p; // 一定会成功&#125; 从Java 14开始，判断instanceof后，可以直接转型为指定变量，避免再次强制转型。例如，对于以下代码： 12345Object obj = &quot;hello&quot;;if (obj instanceof String) &#123; String s = (String) obj; System.out.println(s.toUpperCase());&#125; 可以改写如下： 1234567891011// instanceof variable:public class Main &#123; public static void main(String[] args) &#123; Object obj = &quot;hello&quot;; if (obj instanceof String s) &#123; // 可以直接使用变量s: System.out.println(s.toUpperCase()); &#125; &#125;&#125; 使用instanceof variable这种判断并转型为指定类型变量的语法时，必须打开编译器开关--source 14和--enable-preview。 区分继承和组合在使用继承时，我们要注意逻辑一致性。 考察下面的Book类： 12345class Book &#123; protected String name; public String getName() &#123;...&#125; public void setName(String name) &#123;...&#125;&#125; 这个Book类也有name字段，那么，我们能不能让Student继承自Book呢？ 123class Student extends Book &#123; protected int score;&#125; 显然，从逻辑上讲，这是不合理的，Student不应该从Book继承，而应该从Person继承。 究其原因，是因为Student是Person的一种，它们是is关系，而Student并不是Book。实际上Student和Book的关系是has关系。 具有has关系不应该使用继承，而是使用组合，即Student可以持有一个Book实例： 1234class Student extends Person &#123; protected Book book; protected int score;&#125; 因此，继承是is关系，组合是has关系。 练习定义PrimaryStudent，从Student继承，并新增一个grade字段： 123456789101112131415161718192021222324252627public class Person &#123; protected String name; protected int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 1234567891011121314public class Student extends Person &#123; protected int score; public Student(String name, int age, int score) &#123; super(name, age); this.score = score; &#125; public int getScore() &#123; return score; &#125;&#125; 12345678910111213public class PrimaryStudent extends Student&#123; protected int grade; public PrimaryStudent(String name, int age, int score, int grade)&#123; super(name, age, score); this.grade = grade; &#125; public int getGrade()&#123; return grade; &#125;&#125; 1234567891011public class Main &#123; public static void main(String[] args) &#123; Person p = new Person(&quot;小明&quot;, 12); Student s = new Student(&quot;小红&quot;, 20, 99); // TODO: 定义PrimaryStudent，从Student继承，新增grade字段: Student ps = new PrimaryStudent(&quot;小军&quot;, 9, 100, 5); System.out.println(ps.getScore()); &#125;&#125; 小结 继承是面向对象编程的一种强大的代码复用方式； Java只允许单继承，所有类最终的根类是Object； protected允许子类访问父类的字段和方法； 子类的构造方法可以通过super()调用父类的构造方法； 可以安全地向上转型为更抽象的类型； 可以强制向下转型，最好借助instanceof判断； 子类和父类的关系是is，has关系不能用继承。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"02-面向对象编程","slug":"Java/02-面向对象编程","permalink":"http://example.com/categories/Java/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"name":"--01-面向对象基础","slug":"Java/02-面向对象编程/01-面向对象基础","permalink":"http://example.com/categories/Java/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/01-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java-02-01-03-方法重载","slug":"liaoxuefeng/02-面向对象编程/01-面向对象基础/03-方法重载","date":"2020-08-03T20:00:00.000Z","updated":"2020-08-15T16:44:57.268Z","comments":true,"path":"2020/08/04/liaoxuefeng/02-面向对象编程/01-面向对象基础/03-方法重载/","link":"","permalink":"http://example.com/2020/08/04/liaoxuefeng/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/01-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/03-%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD/","excerpt":"","text":"在一个类中，我们可以定义多个方法。如果有一系列方法，它们的功能都是类似的，只有参数有所不同，那么，可以把这一组方法名做成同名方法。例如，在Hello类中，定义多个hello()方法： 1234567891011121314151617class Hello &#123; public void hello() &#123; System.out.println(&quot;Hello, world!&quot;); &#125; public void hello(String name) &#123; System.out.println(&quot;Hello, &quot; + name + &quot;!&quot;); &#125; public void hello(String name, int age) &#123; if (age &lt; 18) &#123; System.out.println(&quot;Hi, &quot; + name + &quot;!&quot;); &#125; else &#123; System.out.println(&quot;Hello, &quot; + name + &quot;!&quot;); &#125; &#125;&#125; 这种方法名相同，但各自的参数不同，称为方法重载（Overload）。 注意：方法重载的返回值类型通常都是相同的。 方法重载的目的是，功能类似的方法使用同一名字，更容易记住，因此，调用起来更简单。 举个例子，String类提供了多个重载方法indexOf()，可以查找子串： int indexOf(int ch)：根据字符的Unicode码查找； int indexOf(String str)：根据字符串查找； int indexOf(int ch, int fromIndex)：根据字符查找，但指定起始位置； int indexOf(String str, int fromIndex)根据字符串查找，但指定起始位置。 试一试： 12345678910111213// String.indexOf()public class Main &#123; public static void main(String[] args) &#123; String s = &quot;Test string&quot;; int n1 = s.indexOf(&#x27;t&#x27;); int n2 = s.indexOf(&quot;st&quot;); int n3 = s.indexOf(&quot;st&quot;, 4); System.out.println(n1); System.out.println(n2); System.out.println(n3); &#125;&#125; 练习1234567891011121314151617public class Person &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public void setName(String name１, String name2) &#123; this.name = name１ + &quot; &quot; + name2; &#125;&#125; 1234567891011121314public class Main &#123; public static void main(String[] args) &#123; Person ming = new Person(); ming.setName(&quot;Xiao Ming&quot;); System.out.println(ming.getName()); Person hong = new Person(); hong.setName(&quot;Xiao&quot;, &quot;Hong&quot;); System.out.println(hong.getName()); &#125;&#125; 小结方法重载是指多个方法的方法名相同，但各自的参数不同； 重载方法应该完成类似的功能，参考String的indexOf()； 重载方法返回值类型应该相同。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"02-面向对象编程","slug":"Java/02-面向对象编程","permalink":"http://example.com/categories/Java/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"name":"--01-面向对象基础","slug":"Java/02-面向对象编程/01-面向对象基础","permalink":"http://example.com/categories/Java/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/01-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java-02-01-02-构造方法","slug":"liaoxuefeng/02-面向对象编程/01-面向对象基础/02-构造方法","date":"2020-08-03T19:00:00.000Z","updated":"2020-08-15T16:44:14.453Z","comments":true,"path":"2020/08/04/liaoxuefeng/02-面向对象编程/01-面向对象基础/02-构造方法/","link":"","permalink":"http://example.com/2020/08/04/liaoxuefeng/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/01-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/02-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/","excerpt":"","text":"创建实例的时候，我们经常需要同时初始化这个实例的字段，例如： 123Person ming = new Person();ming.setName(&quot;小明&quot;);ming.setAge(12); 初始化对象实例需要3行代码，而且，如果忘了调用setName()或者setAge()，这个实例内部的状态就是不正确的。 能否在创建对象实例时就把内部字段全部初始化为合适的值？ 完全可以。 这时，我们就需要构造方法。 创建实例的时候，实际上是通过构造方法来初始化实例的。我们先来定义一个构造方法，能在创建Person实例的时候，一次性传入name和age，完成初始化： 123456789101112131415161718192021222324252627// 构造方法public class Main &#123; public static void main(String[] args) &#123; Person p = new Person(&quot;Xiao Ming&quot;, 15); System.out.println(p.getName()); System.out.println(p.getAge()); &#125;&#125;class Person &#123; private String name; private int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return this.name; &#125; public int getAge() &#123; return this.age; &#125;&#125; 由于构造方法是如此特殊，所以构造方法的名称就是类名。构造方法的参数没有限制，在方法内部，也可以编写任意语句。但是，和普通方法相比，构造方法没有返回值（也没有void），调用构造方法，必须用new操作符。 默认构造方法是不是任何class都有构造方法？是的。 那前面我们并没有为Person类编写构造方法，为什么可以调用new Person()？ 原因是如果一个类没有定义构造方法，编译器会自动为我们生成一个默认构造方法，它没有参数，也没有执行语句，类似这样： 1234class Person &#123; public Person() &#123; &#125;&#125; 要特别注意的是，如果我们自定义了一个构造方法，那么，编译器就不再自动创建默认构造方法： 12345678910111213141516171819202122232425// 构造方法public class Main &#123; public static void main(String[] args) &#123; Person p = new Person(); // 编译错误:找不到这个构造方法 &#125;&#125;class Person &#123; private String name; private int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return this.name; &#125; public int getAge() &#123; return this.age; &#125;&#125; 如果既要能使用带参数的构造方法，又想保留不带参数的构造方法，那么只能把两个构造方法都定义出来： 1234567891011121314151617181920212223242526272829// 构造方法public class Main &#123; public static void main(String[] args) &#123; Person p1 = new Person(&quot;Xiao Ming&quot;, 15); // 既可以调用带参数的构造方法 Person p2 = new Person(); // 也可以调用无参数构造方法 &#125;&#125;class Person &#123; private String name; private int age; public Person() &#123; &#125; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return this.name; &#125; public int getAge() &#123; return this.age; &#125;&#125; 没有在构造方法中初始化字段时，引用类型的字段默认是null，数值类型的字段用默认值，int类型默认值是0，布尔类型默认值是false： 1234567class Person &#123; private String name; // 默认初始化为null private int age; // 默认初始化为0 public Person() &#123; &#125;&#125; 也可以对字段直接进行初始化： 1234class Person &#123; private String name = &quot;Unamed&quot;; private int age = 10;&#125; 那么问题来了：既对字段进行初始化，又在构造方法中对字段进行初始化： 123456789class Person &#123; private String name = &quot;Unamed&quot;; private int age = 10; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125;&#125; 当我们创建对象的时候，new Person(&quot;Xiao Ming&quot;, 12)得到的对象实例，字段的初始值是啥？ 在Java中，创建对象实例的时候，按照如下顺序进行初始化： 先初始化字段，例如，int age = 10;表示字段初始化为10，double salary;表示字段默认初始化为0，String name;表示引用类型字段默认初始化为null； 执行构造方法的代码进行初始化。 因此，构造方法的代码由于后运行，所以，new Person(&quot;Xiao Ming&quot;, 12)的字段值最终由构造方法的代码确定。 多构造方法可以定义多个构造方法，在通过new操作符调用的时候，编译器通过构造方法的参数数量、位置和类型自动区分： 1234567891011121314151617class Person &#123; private String name; private int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public Person(String name) &#123; this.name = name; this.age = 12; &#125; public Person() &#123; &#125;&#125; 如果调用new Person(&quot;Xiao Ming&quot;, 20);，会自动匹配到构造方法public Person(String, int)。 如果调用new Person(&quot;Xiao Ming&quot;);，会自动匹配到构造方法public Person(String)。 如果调用new Person();，会自动匹配到构造方法public Person()。 一个构造方法可以调用其他构造方法，这样做的目的是便于代码复用。调用其他构造方法的语法是this(…)： 1234567891011121314151617class Person &#123; private String name; private int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public Person(String name) &#123; this(name, 18); // 调用另一个构造方法Person(String, int) &#125; public Person() &#123; this(&quot;Unnamed&quot;); // 调用另一个构造方法Person(String) &#125;&#125; 练习请给Person类增加(String, int)的构造方法： 123456789101112131415161718192021222324252627public class Person &#123; private String name; private int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 12345678910public class Main &#123; public static void main(String[] args) &#123; // FIXME: 给Person增加构造方法: Person ming = new Person(&quot;小明&quot;, 12); System.out.println(ming.getName()); System.out.println(ming.getAge()); &#125;&#125; 小结实例在创建时通过new操作符会调用其对应的构造方法，构造方法用于初始化实例； 没有定义构造方法时，编译器会自动创建一个默认的无参数构造方法； 可以定义多个构造方法，编译器根据参数自动判断； 可以在一个构造方法内部调用另一个构造方法，便于代码复用。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"02-面向对象编程","slug":"Java/02-面向对象编程","permalink":"http://example.com/categories/Java/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"name":"--01-面向对象基础","slug":"Java/02-面向对象编程/01-面向对象基础","permalink":"http://example.com/categories/Java/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/01-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java-02-01-01-方法","slug":"liaoxuefeng/02-面向对象编程/01-面向对象基础/01-方法","date":"2020-08-03T18:00:00.000Z","updated":"2020-08-15T16:43:42.780Z","comments":true,"path":"2020/08/04/liaoxuefeng/02-面向对象编程/01-面向对象基础/01-方法/","link":"","permalink":"http://example.com/2020/08/04/liaoxuefeng/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/01-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/01-%E6%96%B9%E6%B3%95/","excerpt":"","text":"一个class可以包含多个field，例如，我们给Person类就定义了两个field： 1234class Person &#123; public String name; public int age;&#125; 但是，直接把field用public暴露给外部可能会破坏封装性。比如，代码可以这样写： 123Person ming = new Person();ming.name = &quot;Xiao Ming&quot;;ming.age = -99; // age设置为负数 显然，直接操作field，容易造成逻辑混乱。为了避免外部代码直接去访问field，我们可以用private修饰field，拒绝外部访问： 1234class Person &#123; private String name; private int age;&#125; 试试private修饰的field有什么效果： 1234567891011121314// private fieldpublic class Main &#123; public static void main(String[] args) &#123; Person ming = new Person(); ming.name = &quot;Xiao Ming&quot;; // 对字段name赋值 ming.age = 12; // 对字段age赋值 &#125;&#125;class Person &#123; private String name; private int age;&#125; 是不是编译报错？把访问field的赋值语句去了就可以正常编译了。 把field从public改成private，外部代码不能访问这些field，那我们定义这些field有什么用？怎么才能给它赋值？怎么才能读取它的值？ 所以我们需要使用方法（method）来让外部代码可以间接修改field： 12345678910111213141516171819202122232425262728293031323334// private fieldpublic class Main &#123; public static void main(String[] args) &#123; Person ming = new Person(); ming.setName(&quot;Xiao Ming&quot;); // 设置name ming.setAge(12); // 设置age System.out.println(ming.getName() + &quot;, &quot; + ming.getAge()); &#125;&#125;class Person &#123; private String name; private int age; public String getName() &#123; return this.name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return this.age; &#125; public void setAge(int age) &#123; if (age &lt; 0 || age &gt; 100) &#123; throw new IllegalArgumentException(&quot;invalid age value&quot;); &#125; this.age = age; &#125;&#125; 虽然外部代码不能直接修改private字段，但是，外部代码可以调用方法setName()和setAge()来间接修改private字段。在方法内部，我们就有机会检查参数对不对。比如，setAge()就会检查传入的参数，参数超出了范围，直接报错。这样，外部代码就没有任何机会把age设置成不合理的值。 对setName()方法同样可以做检查，例如，不允许传入null和空字符串： 123456public void setName(String name) &#123; if (name == null || name.isBlank()) &#123; throw new IllegalArgumentException(&quot;invalid name&quot;); &#125; this.name = name.strip(); // 去掉首尾空格&#125; 同样，外部代码不能直接读取private字段，但可以通过getName()和getAge()间接获取private字段的值。 所以，一个类通过定义方法，就可以给外部代码暴露一些操作的接口，同时，内部自己保证逻辑一致性。 调用方法的语法是实例变量.方法名(参数);。一个方法调用就是一个语句，所以不要忘了在末尾加;。例如：ming.setName(&quot;Xiao Ming&quot;);。 定义方法从上面的代码可以看出，定义方法的语法是： 1234修饰符 方法返回类型 方法名(方法参数列表) &#123; 若干方法语句; return 方法返回值;&#125; 方法返回值通过return语句实现，如果没有返回值，返回类型设置为void，可以省略return。 private方法有public方法，自然就有private方法。和private字段一样，private方法不允许外部调用，那我们定义private方法有什么用？ 定义private方法的理由是内部方法是可以调用private方法的。例如： 123456789101112131415161718192021222324252627// private methodpublic class Main &#123; public static void main(String[] args) &#123; Person ming = new Person(); ming.setBirth(2008); System.out.println(ming.getAge()); &#125;&#125;class Person &#123; private String name; private int birth; public void setBirth(int birth) &#123; this.birth = birth; &#125; public int getAge() &#123; return calcAge(2019); // 调用private方法 &#125; // private方法: private int calcAge(int currentYear) &#123; return currentYear - this.birth; &#125;&#125; 观察上述代码，calcAge()是一个private方法，外部代码无法调用，但是，内部方法getAge()可以调用它。 此外，我们还注意到，这个Person类只定义了birth字段，没有定义age字段，获取age时，通过方法getAge()返回的是一个实时计算的值，并非存储在某个字段的值。这说明方法可以封装一个类的对外接口，调用方不需要知道也不关心Person实例在内部到底有没有age字段。 this变量在方法内部，可以使用一个隐含的变量this，它始终指向当前实例。因此，通过this.field就可以访问当前实例的字段。 如果没有命名冲突，可以省略this。例如： 1234567class Person &#123; private String name; public String getName() &#123; return name; // 相当于this.name &#125;&#125; 但是，如果有局部变量和字段重名，那么局部变量优先级更高，就必须加上this： 1234567class Person &#123; private String name; public void setName(String name) &#123; this.name = name; // 前面的this不可少，少了就变成局部变量name了 &#125;&#125; 方法参数方法可以包含0个或任意个参数。方法参数用于接收传递给方法的变量值。调用方法时，必须严格按照参数的定义一一传递。例如： 123456class Person &#123; ... public void setNameAndAge(String name, int age) &#123; ... &#125;&#125; 调用这个setNameAndAge()方法时，必须有两个参数，且第一个参数必须为String，第二个参数必须为int： 123Person ming = new Person();ming.setNameAndAge(&quot;Xiao Ming&quot;); // 编译错误：参数个数不对ming.setNameAndAge(12, &quot;Xiao Ming&quot;); // 编译错误：参数类型不对 可变参数可变参数用类型...定义，可变参数相当于数组类型： 1234567class Group &#123; private String[] names; public void setNames(String... names) &#123; this.names = names; &#125;&#125; 上面的setNames()就定义了一个可变参数。调用时，可以这么写： 12345Group g = new Group();g.setNames(&quot;Xiao Ming&quot;, &quot;Xiao Hong&quot;, &quot;Xiao Jun&quot;); // 传入3个Stringg.setNames(&quot;Xiao Ming&quot;, &quot;Xiao Hong&quot;); // 传入2个Stringg.setNames(&quot;Xiao Ming&quot;); // 传入1个Stringg.setNames(); // 传入0个String 完全可以把可变参数改写为String[]类型： 1234567class Group &#123; private String[] names; public void setNames(String[] names) &#123; this.names = names; &#125;&#125; 但是，调用方需要自己先构造String[]，比较麻烦。例如： 12Group g = new Group();g.setNames(new String[] &#123;&quot;Xiao Ming&quot;, &quot;Xiao Hong&quot;, &quot;Xiao Jun&quot;&#125;); // 传入1个String[] 另一个问题是，调用方可以传入null： 12Group g = new Group();g.setNames(null); 而可变参数可以保证无法传入null，因为传入0个参数时，接收到的实际值是一个空数组而不是null。 参数绑定调用方把参数传递给实例方法时，调用时传递的值会按参数位置一一绑定。 那什么是参数绑定？ 我们先观察一个基本类型参数的传递： 123456789101112131415161718192021222324// 基本类型参数绑定public class Main &#123; public static void main(String[] args) &#123; Person p = new Person(); int n = 15; // n的值为15 p.setAge(n); // 传入n的值 System.out.println(p.getAge()); // 15 n = 20; // n的值改为20 System.out.println(p.getAge()); // 15还是20? &#125;&#125;class Person &#123; private int age; public int getAge() &#123; return this.age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 运行代码，从结果可知，修改外部的局部变量n，不影响实例p的age字段，原因是setAge()方法获得的参数，复制了n的值，因此，p.age和局部变量n互不影响。 结论：基本类型参数的传递，是调用方值的复制。双方各自的后续修改，互不影响。 我们再看一个传递引用参数的例子： 123456789101112131415161718192021222324// 引用类型参数绑定public class Main &#123; public static void main(String[] args) &#123; Person p = new Person(); String[] fullname = new String[] &#123; &quot;Homer&quot;, &quot;Simpson&quot; &#125;; p.setName(fullname); // 传入fullname数组 System.out.println(p.getName()); // &quot;Homer Simpson&quot; fullname[0] = &quot;Bart&quot;; // fullname数组的第一个元素修改为&quot;Bart&quot; System.out.println(p.getName()); // &quot;Homer Simpson&quot;还是&quot;Bart Simpson&quot;? &#125;&#125;class Person &#123; private String[] name; public String getName() &#123; return this.name[0] + &quot; &quot; + this.name[1]; &#125; public void setName(String[] name) &#123; this.name = name; &#125;&#125; 注意到setName()的参数现在是一个数组。一开始，把fullname数组传进去，然后，修改fullname数组的内容，结果发现，实例p的字段p.name也被修改了！ 结论：引用类型参数的传递，调用方的变量，和接收方的参数变量，指向的是同一个对象。双方任意一方对这个对象的修改，都会影响对方（因为指向同一个对象嘛）。 有了上面的结论，我们再看一个例子： 123456789101112131415161718192021222324// 引用类型参数绑定public class Main &#123; public static void main(String[] args) &#123; Person p = new Person(); String bob = &quot;Bob&quot;; p.setName(bob); // 传入bob变量 System.out.println(p.getName()); // &quot;Bob&quot; bob = &quot;Alice&quot;; // bob改名为Alice System.out.println(p.getName()); // &quot;Bob&quot;还是&quot;Alice&quot;? &#125;&#125;class Person &#123; private String name; public String getName() &#123; return this.name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 不要怀疑引用参数绑定的机制，试解释为什么上面的代码两次输出都是&quot;Bob&quot;。 练习12345678910111213141516171819202122public class Person &#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge()&#123; return age; &#125; public void setAge(int age)&#123; this.age = age; &#125;&#125; 123456789101112public class Main &#123; public static void main(String[] args) &#123; Person ming = new Person(); ming.setName(&quot;小明&quot;); System.out.println(ming.getName()); ming.setAge(12); System.out.println(ming.getAge()); &#125;&#125; 小结 方法可以让外部代码安全地访问实例字段； 方法是一组执行语句，并且可以执行任意逻辑； 方法内部遇到return时返回，void表示不返回任何值（注意和返回null不同）； 外部代码通过public方法操作实例，内部代码可以调用private方法； 理解方法的参数绑定。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"02-面向对象编程","slug":"Java/02-面向对象编程","permalink":"http://example.com/categories/Java/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"name":"--01-面向对象基础","slug":"Java/02-面向对象编程/01-面向对象基础","permalink":"http://example.com/categories/Java/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/01-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java-02-01-00-面向对象基础","slug":"liaoxuefeng/02-面向对象编程/01-面向对象基础/00-面向对象基础","date":"2020-08-03T17:00:00.000Z","updated":"2020-08-15T16:42:50.320Z","comments":true,"path":"2020/08/04/liaoxuefeng/02-面向对象编程/01-面向对象基础/00-面向对象基础/","link":"","permalink":"http://example.com/2020/08/04/liaoxuefeng/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/01-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/00-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/","excerpt":"","text":"面向对象编程，是一种通过对象的方式，把现实世界映射到计算机模型的一种编程方法。 现实世界中，我们定义了“人”这种抽象概念，而具体的人则是“小明”、“小红”、“小军”等一个个具体的人。所以，“人”可以定义为一个类（class），而具体的人则是实例（instance）： 现实世界 计算机模型 Java代码 人 类 / class class Person { } 小明 实例 / ming Person ming = new Person() 小红 实例 / hong Person hong = new Person() 小军 实例 / jun Person jun = new Person() 同样的，“书”也是一种抽象的概念，所以它是类，而《Java核心技术》、《Java编程思想》、《Java学习笔记》则是实例： 现实世界 计算机模型 Java代码 书 类 / class class Book { } Java核心技术 实例 / book1 Book book1 = new Book() Java编程思想 实例 / book2 Book book2 = new Book() Java学习笔记 实例 / book3 Book book3 = new Book() class和instance所以，只要理解了class和instance的概念，基本上就明白了什么是面向对象编程。 class是一种对象模版，它定义了如何创建实例，因此，class本身就是一种数据类型： 而instance是对象实例，instance是根据class创建的实例，可以创建多个instance，每个instance类型相同，但各自属性可能不相同： 定义class在Java中，创建一个类，例如，给这个类命名为Person，就是定义一个class： 1234class Person &#123; public String name; public int age;&#125; 一个class可以包含多个字段（field），字段用来描述一个类的特征。上面的Person类，我们定义了两个字段，一个是String类型的字段，命名为name，一个是int类型的字段，命名为age。因此，通过class，把一组数据汇集到一个对象上，实现了数据封装。 public是用来修饰字段的，它表示这个字段可以被外部访问。 我们再看另一个Book类的定义： 123456class Book &#123; public String name; public String author; public String isbn; public double price;&#125; 请指出Book类的各个字段。 创建实例定义了class，只是定义了对象模版，而要根据对象模版创建出真正的对象实例，必须用new操作符。 new操作符可以创建一个实例，然后，我们需要定义一个引用类型的变量来指向这个实例： 1Person ming = new Person(); 上述代码创建了一个Person类型的实例，并通过变量ming指向它。 注意区分Person ming是定义Person类型的变量ming，而new Person()是创建Person实例。 有了指向这个实例的变量，我们就可以通过这个变量来操作实例。访问实例变量可以用变量.字段，例如： 1234567ming.name = &quot;Xiao Ming&quot;; // 对字段name赋值ming.age = 12; // 对字段age赋值System.out.println(ming.name); // 访问字段namePerson hong = new Person();hong.name = &quot;Xiao Hong&quot;;hong.age = 15; 上述两个变量分别指向两个不同的实例，它们在内存中的结构如下： 123456789101112 ┌──────────────────┐ming ──────&gt;│Person instance │ ├──────────────────┤ │name &#x3D; &quot;Xiao Ming&quot;│ │age &#x3D; 12 │ └──────────────────┘ ┌──────────────────┐hong ──────&gt;│Person instance │ ├──────────────────┤ │name &#x3D; &quot;Xiao Hong&quot;│ │age &#x3D; 15 │ └──────────────────┘ 两个instance拥有class定义的name和age字段，且各自都有一份独立的数据，互不干扰。 练习请定义一个City类，该class具有如下字段: name: 名称，String类型 latitude: 纬度，double类型 longitude: 经度，double类型 实例化几个City并赋值，然后打印。 123456789101112131415161718// Citypublic class Main &#123; public static void main(String[] args) &#123; City bj = new City(); bj.name = &quot;Beijing&quot;; bj.latitude = 39.903; bj.longitude = 116.401; System.out.println(bj.name); System.out.println(&quot;location: &quot; + bj.latitude + &quot;, &quot; + bj.longitude); &#125;&#125;class City &#123; public String name; public double latitude; public double longitude;&#125; 小结在OOP中，class和instance是“模版”和“实例”的关系； 定义class就是定义了一种数据类型，对应的instance是这种数据类型的实例； class定义的field，在每个instance都会拥有各自的field，且互不干扰； 通过new操作符创建新的instance，然后用变量指向它，即可通过变量来引用这个instance； 访问实例字段的方法是变量名.字段名； 指向instance的变量都是引用变量。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"02-面向对象编程","slug":"Java/02-面向对象编程","permalink":"http://example.com/categories/Java/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"name":"--01-面向对象基础","slug":"Java/02-面向对象编程/01-面向对象基础","permalink":"http://example.com/categories/Java/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/01-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java-02-00-面向对象编程","slug":"liaoxuefeng/02-面向对象编程/00-面向对象编程","date":"2020-08-03T16:00:00.000Z","updated":"2020-08-15T16:41:13.575Z","comments":true,"path":"2020/08/04/liaoxuefeng/02-面向对象编程/00-面向对象编程/","link":"","permalink":"http://example.com/2020/08/04/liaoxuefeng/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/00-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/","excerpt":"","text":"Java是一种面向对象的编程语言。面向对象编程，英文是Object-Oriented Programming，简称OOP。 那什么是面向对象编程？ 和面向对象编程不同的，是面向过程编程。面向过程编程，是把模型分解成一步一步的过程。比如，老板告诉你，要编写一个TODO任务，必须按照以下步骤一步一步来： 读取文件； 编写TODO； 保存文件。 而面向对象编程，顾名思义，你得首先有个对象： 有了对象后，就可以和对象进行互动： 123GirlFriend gf = new GirlFriend();gf.name = &quot;Alice&quot;;gf.send(&quot;flowers&quot;); 因此，面向对象编程，是一种通过对象的方式，把现实世界映射到计算机模型的一种编程方法。 在本章中，我们将讨论： 面向对象的基本概念，包括： 类 实例 方法 面向对象的实现方式，包括： 继承 多态 Java语言本身提供的机制，包括： package classpath jar 以及Java标准库提供的核心类，包括： 字符串 包装类型 JavaBean 枚举 常用工具类 通过本章的学习，完全可以理解并掌握面向对象的基本思想，但不保证能找到对象。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"02-面向对象编程","slug":"Java/02-面向对象编程","permalink":"http://example.com/categories/Java/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java-01-03-04-命令行参数","slug":"liaoxuefeng/01-Java快速入门/03-数组操作/04-命令行参数","date":"2020-08-02T20:00:00.000Z","updated":"2020-08-14T18:37:18.778Z","comments":true,"path":"2020/08/03/liaoxuefeng/01-Java快速入门/03-数组操作/04-命令行参数/","link":"","permalink":"http://example.com/2020/08/03/liaoxuefeng/01-Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/03-%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/04-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0/","excerpt":"","text":"Java程序的入口是main方法，而main方法可以接受一个命令行参数，它是一个String[]数组。 这个命令行参数由JVM接收用户输入并传给main方法： 1234567public class Main &#123; public static void main(String[] args) &#123; for (String arg : args) &#123; System.out.println(arg); &#125; &#125;&#125; 我们可以利用接收到的命令行参数，根据不同的参数执行不同的代码。例如，实现一个-version参数，打印程序版本号： 12345678910public class Main &#123; public static void main(String[] args) &#123; for (String arg : args) &#123; if (&quot;-version&quot;.equals(arg)) &#123; System.out.println(&quot;v 1.0&quot;); break; &#125; &#125; &#125;&#125; 上面这个程序必须在命令行执行，我们先编译它： 1$ javac Main.java 然后，执行的时候，给它传递一个-version参数： 12$ java Main -versionv 1.0 这样，程序就可以根据传入的命令行参数，作出不同的响应。 小结命令行参数类型是String[]数组； 命令行参数由JVM接收用户输入并传给main方法； 如何解析命令行参数需要由程序自己实现。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"01-Java快速入门","slug":"Java/01-Java快速入门","permalink":"http://example.com/categories/Java/01-Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"name":"--03-数组操作","slug":"Java/01-Java快速入门/03-数组操作","permalink":"http://example.com/categories/Java/01-Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/03-%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java-01-03-03-多维数组","slug":"liaoxuefeng/01-Java快速入门/03-数组操作/03-多维数组","date":"2020-08-02T19:00:00.000Z","updated":"2020-08-14T18:37:12.767Z","comments":true,"path":"2020/08/03/liaoxuefeng/01-Java快速入门/03-数组操作/03-多维数组/","link":"","permalink":"http://example.com/2020/08/03/liaoxuefeng/01-Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/03-%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/03-%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84/","excerpt":"","text":"二维数组二维数组就是数组的数组。定义一个二维数组如下： 123456789101112// 二维数组public class Main &#123; public static void main(String[] args) &#123; int[][] ns = &#123; &#123; 1, 2, 3, 4 &#125;, &#123; 5, 6, 7, 8 &#125;, &#123; 9, 10, 11, 12 &#125; &#125;; System.out.println(ns.length); // 3 &#125;&#125; 因为ns包含3个数组，因此，ns.length为3。实际上ns在内存中的结构如下： 123456789 ┌───┬───┬───┬───┐ ┌───┐ ┌──&gt;│ 1 │ 2 │ 3 │ 4 │ns ─────&gt;│░░░│──┘ └───┴───┴───┴───┘ ├───┤ ┌───┬───┬───┬───┐ │░░░│─────&gt;│ 5 │ 6 │ 7 │ 8 │ ├───┤ └───┴───┴───┴───┘ │░░░│──┐ ┌───┬───┬───┬───┐ └───┘ └──&gt;│ 9 │10 │11 │12 │ └───┴───┴───┴───┘ 如果我们定义一个普通数组arr0，然后把ns[0]赋值给它： 12345678910111213// 二维数组public class Main &#123; public static void main(String[] args) &#123; int[][] ns = &#123; &#123; 1, 2, 3, 4 &#125;, &#123; 5, 6, 7, 8 &#125;, &#123; 9, 10, 11, 12 &#125; &#125;; int[] arr0 = ns[0]; System.out.println(arr0.length); // 4 &#125;&#125; 实际上arr0就获取了ns数组的第0个元素。因为ns数组的每个元素也是一个数组，因此，arr0指向的数组就是&#123; 1, 2, 3, 4 &#125;。在内存中，结构如下： 1234567891011 arr0 ─────┐ ▼ ┌───┬───┬───┬───┐ ┌───┐ ┌──&gt;│ 1 │ 2 │ 3 │ 4 │ns ─────&gt;│░░░│──┘ └───┴───┴───┴───┘ ├───┤ ┌───┬───┬───┬───┐ │░░░│─────&gt;│ 5 │ 6 │ 7 │ 8 │ ├───┤ └───┴───┴───┴───┘ │░░░│──┐ ┌───┬───┬───┬───┐ └───┘ └──&gt;│ 9 │10 │11 │12 │ └───┴───┴───┴───┘ 访问二维数组的某个元素需要使用array[row][col]，例如： 1System.out.println(ns[1][2]); // 7 二维数组的每个数组元素的长度并不要求相同，例如，可以这么定义ns数组： 12345int[][] ns = &#123; &#123; 1, 2, 3, 4 &#125;, &#123; 5, 6 &#125;, &#123; 7, 8, 9 &#125;&#125;; 这个二维数组在内存中的结构如下： 123456789 ┌───┬───┬───┬───┐ ┌───┐ ┌──&gt;│ 1 │ 2 │ 3 │ 4 │ns ─────&gt;│░░░│──┘ └───┴───┴───┴───┘ ├───┤ ┌───┬───┐ │░░░│─────&gt;│ 5 │ 6 │ ├───┤ └───┴───┘ │░░░│──┐ ┌───┬───┬───┐ └───┘ └──&gt;│ 7 │ 8 │ 9 │ └───┴───┴───┘ 要打印一个二维数组，可以使用两层嵌套的for循环： 1234567for (int[] arr : ns) &#123; for (int n : arr) &#123; System.out.print(n); System.out.print(&#x27;, &#x27;); &#125; System.out.println();&#125; 或者使用Java标准库的Arrays.deepToString()： 1234567891011121314// 二维数组import java.util.Arrays;public class Main &#123; public static void main(String[] args) &#123; int[][] ns = &#123; &#123; 1, 2, 3, 4 &#125;, &#123; 5, 6, 7, 8 &#125;, &#123; 9, 10, 11, 12 &#125; &#125;; System.out.println(Arrays.deepToString(ns)); &#125;&#125; 三维数组三维数组就是二维数组的数组。可以这么定义一个三维数组： 123456789101112131415int[][][] ns = &#123; &#123; &#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;, &#123;7, 8, 9&#125; &#125;, &#123; &#123;10, 11&#125;, &#123;12, 13&#125; &#125;, &#123; &#123;14, 15, 16&#125;, &#123;17, 18&#125; &#125;&#125;; 它在内存中的结构如下： 123456789101112131415161718192021 ┌───┬───┬───┐ ┌───┐ ┌──&gt;│ 1 │ 2 │ 3 │ ┌──&gt;│░░░│──┘ └───┴───┴───┘ │ ├───┤ ┌───┬───┬───┐ │ │░░░│─────&gt;│ 4 │ 5 │ 6 │ │ ├───┤ └───┴───┴───┘ │ │░░░│──┐ ┌───┬───┬───┐ ┌───┐ │ └───┘ └──&gt;│ 7 │ 8 │ 9 │ns ────&gt;│░░░│──┘ └───┴───┴───┘ ├───┤ ┌───┐ ┌───┬───┐ │░░░│─────&gt;│░░░│─────&gt;│10 │11 │ ├───┤ ├───┤ └───┴───┘ │░░░│──┐ │░░░│──┐ ┌───┬───┐ └───┘ │ └───┘ └──&gt;│12 │13 │ │ └───┴───┘ │ ┌───┐ ┌───┬───┬───┐ └──&gt;│░░░│─────&gt;│14 │15 │16 │ ├───┤ └───┴───┴───┘ │░░░│──┐ ┌───┬───┐ └───┘ └──&gt;│17 │18 │ └───┴───┘ 如果我们要访问三维数组的某个元素，例如，ns[2][0][1]，只需要顺着定位找到对应的最终元素15即可。 理论上，我们可以定义任意的N维数组。但在实际应用中，除了二维数组在某些时候还能用得上，更高维度的数组很少使用。 练习使用二维数组可以表示一组学生的各科成绩，请计算所有学生的平均分： 12345678910111213141516171819202122232425262728293031/** * 二维数组 */public class Main &#123; public static void main(String[] args) &#123; // 用二维数组表示的学生成绩: int[][] scores = &#123; // &#123;82, 90, 91&#125;, &#123;68, 72, 64&#125;, &#123;95, 91, 89&#125;, &#123;67, 52, 60&#125;, &#123;79, 81, 85&#125;, &#125;; double sum = 0; int cnt = 0; for (int i = 0; i &lt; scores.length; i++) &#123; for (int j = 0; j &lt; scores[i].length; j++) &#123; sum += scores[i][j]; cnt++; &#125; &#125; double average = sum / cnt; if (Math.abs(average - 77.733333) &lt; 0.000001) &#123; System.out.println(&quot;测试成功&quot;); &#125; else &#123; System.out.println(&quot;测试失败&quot;); &#125; &#125;&#125; 小结二维数组就是数组的数组，三维数组就是二维数组的数组； 多维数组的每个数组元素长度都不要求相同； 打印多维数组可以使用Arrays.deepToString()； 最常见的多维数组是二维数组，访问二维数组的一个元素使用array[row][col]。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"01-Java快速入门","slug":"Java/01-Java快速入门","permalink":"http://example.com/categories/Java/01-Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"name":"--03-数组操作","slug":"Java/01-Java快速入门/03-数组操作","permalink":"http://example.com/categories/Java/01-Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/03-%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java-01-03-02-数组排序","slug":"liaoxuefeng/01-Java快速入门/03-数组操作/02-数组排序","date":"2020-08-02T18:00:00.000Z","updated":"2020-08-14T18:37:09.911Z","comments":true,"path":"2020/08/03/liaoxuefeng/01-Java快速入门/03-数组操作/02-数组排序/","link":"","permalink":"http://example.com/2020/08/03/liaoxuefeng/01-Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/03-%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/02-%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F/","excerpt":"","text":"对数组进行排序是程序中非常基本的需求。常用的排序算法有冒泡排序、插入排序和快速排序等。 我们来看一下如何使用冒泡排序算法对一个整型数组从小到大进行排序： 1234567891011121314151617181920212223// 冒泡排序import java.util.Arrays;public class Main &#123; public static void main(String[] args) &#123; int[] ns = &#123; 28, 12, 89, 73, 65, 18, 96, 50, 8, 36 &#125;; // 排序前: System.out.println(Arrays.toString(ns)); for (int i = 0; i &lt; ns.length - 1; i++) &#123; for (int j = 0; j &lt; ns.length - i - 1; j++) &#123; if (ns[j] &gt; ns[j+1]) &#123; // 交换ns[j]和ns[j+1]: int tmp = ns[j]; ns[j] = ns[j+1]; ns[j+1] = tmp; &#125; &#125; &#125; // 排序后: System.out.println(Arrays.toString(ns)); &#125;&#125; 冒泡排序的特点是，每一轮循环后，最大的一个数被交换到末尾，因此，下一轮循环就可以“刨除”最后的数，每一轮循环都比上一轮循环的结束位置靠前一位。 另外，注意到交换两个变量的值必须借助一个临时变量。像这么写是错误的： 12345int x = 1;int y = 2;x = y; // x现在是2y = x; // y现在还是2 正确的写法是： 123456int x = 1;int y = 2;int t = x; // 把x的值保存在临时变量t中, t现在是1x = y; // x现在是2y = t; // y现在是t的值1 实际上，Java的标准库已经内置了排序功能，我们只需要调用JDK提供的Arrays.sort()就可以排序： 1234567891011// 排序import java.util.Arrays;public class Main &#123; public static void main(String[] args) &#123; int[] ns = &#123; 28, 12, 89, 73, 65, 18, 96, 50, 8, 36 &#125;; Arrays.sort(ns); System.out.println(Arrays.toString(ns)); &#125;&#125; 必须注意，对数组排序实际上修改了数组本身。例如，排序前的数组是： 1int[] ns = &#123; 9, 3, 6, 5 &#125;; 在内存中，这个整型数组表示如下： 123 ┌───┬───┬───┬───┐ns───&gt;│ 9 │ 3 │ 6 │ 5 │ └───┴───┴───┴───┘ 当我们调用Arrays.sort(ns);后，这个整型数组在内存中变为： 123 ┌───┬───┬───┬───┐ns───&gt;│ 3 │ 5 │ 6 │ 9 │ └───┴───┴───┴───┘ 即变量ns指向的数组内容已经被改变了。 如果对一个字符串数组进行排序，例如： 1String[] ns = &#123; &quot;banana&quot;, &quot;apple&quot;, &quot;pear&quot; &#125;; 排序前，这个数组在内存中表示如下： 12345678 ┌──────────────────────────────────┐ ┌───┼──────────────────────┐ │ │ │ ▼ ▼ ┌───┬─┴─┬─┴─┬───┬────────┬───┬───────┬───┬──────┬───┐ns ─────&gt;│░░░│░░░│░░░│ │&quot;banana&quot;│ │&quot;apple&quot;│ │&quot;pear&quot;│ │ └─┬─┴───┴───┴───┴────────┴───┴───────┴───┴──────┴───┘ │ ▲ └─────────────────┘ 调用Arrays.sort(ns);排序后，这个数组在内存中表示如下： 12345678 ┌──────────────────────────────────┐ ┌───┼──────────┐ │ │ │ ▼ ▼ ┌───┬─┴─┬─┴─┬───┬────────┬───┬───────┬───┬──────┬───┐ns ─────&gt;│░░░│░░░│░░░│ │&quot;banana&quot;│ │&quot;apple&quot;│ │&quot;pear&quot;│ │ └─┬─┴───┴───┴───┴────────┴───┴───────┴───┴──────┴───┘ │ ▲ └──────────────────────────────┘ 原来的3个字符串在内存中均没有任何变化，但是ns数组的每个元素指向变化了。 练习请思考如何实现对数组进行降序排序： 1234567891011121314151617181920212223242526272829import java.util.Arrays;/** * 降序排序 */public class Main &#123; public static void main(String[] args) &#123; int[] ns = &#123;28, 12, 89, 73, 65, 18, 96, 50, 8, 36&#125;; // 排序前: System.out.println(Arrays.toString(ns)); // 排序操作 Arrays.sort(ns); int[] ns2 = new int[ns.length]; for (int i = 0; i &lt; ns.length; i++) &#123; ns2[i] = ns[ns.length - i - 1]; &#125; ns = ns2; // 排序后: System.out.println(Arrays.toString(ns)); if (Arrays.toString(ns).equals(&quot;[96, 89, 73, 65, 50, 36, 28, 18, 12, 8]&quot;)) &#123; System.out.println(&quot;测试成功&quot;); &#125; else &#123; System.out.println(&quot;测试失败&quot;); &#125; &#125;&#125; 小结常用的排序算法有冒泡排序、插入排序和快速排序等； 冒泡排序使用两层for循环实现排序； 交换两个变量的值需要借助一个临时变量。 可以直接使用Java标准库提供的Arrays.sort()进行排序； 对数组排序会直接修改数组本身。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"01-Java快速入门","slug":"Java/01-Java快速入门","permalink":"http://example.com/categories/Java/01-Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"name":"--03-数组操作","slug":"Java/01-Java快速入门/03-数组操作","permalink":"http://example.com/categories/Java/01-Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/03-%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java-01-03-01-遍历数组","slug":"liaoxuefeng/01-Java快速入门/03-数组操作/01-遍历数组","date":"2020-08-02T17:00:00.000Z","updated":"2020-08-14T18:37:06.123Z","comments":true,"path":"2020/08/03/liaoxuefeng/01-Java快速入门/03-数组操作/01-遍历数组/","link":"","permalink":"http://example.com/2020/08/03/liaoxuefeng/01-Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/03-%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/01-%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84/","excerpt":"","text":"我们在Java程序基础里介绍了数组这种数据类型。有了数组，我们还需要来操作它。而数组最常见的一个操作就是遍历。 通过for循环就可以遍历数组。因为数组的每个元素都可以通过索引来访问，因此，使用标准的for循环可以完成一个数组的遍历： 1234567891011// 遍历数组public class Main &#123; public static void main(String[] args) &#123; int[] ns = &#123; 1, 4, 9, 16, 25 &#125;; for (int i=0; i&lt;ns.length; i++) &#123; int n = ns[i]; System.out.println(n); &#125; &#125;&#125; 为了实现for循环遍历，初始条件为i=0，因为索引总是从0开始，继续循环的条件为i&lt;ns.length，因为当i=ns.length时，i已经超出了索引范围（索引范围是0 ~ ns.length-1），每次循环后，i++。 第二种方式是使用for each循环，直接迭代数组的每个元素： 12345678910// 遍历数组public class Main &#123; public static void main(String[] args) &#123; int[] ns = &#123; 1, 4, 9, 16, 25 &#125;; for (int n : ns) &#123; System.out.println(n); &#125; &#125;&#125; 注意：在for (int n : ns)循环中，变量n直接拿到ns数组的元素，而不是索引。 显然for each循环更加简洁。但是，for each循环无法拿到数组的索引，因此，到底用哪一种for循环，取决于我们的需要。 打印数组内容直接打印数组变量，得到的是数组在JVM中的引用地址： 12int[] ns = &#123; 1, 1, 2, 3, 5, 8 &#125;;System.out.println(ns); // 类似 [I@5f184fc6 这并没有什么意义，因为我们希望打印的数组的元素内容。因此，使用for each循环来打印它： 1234int[] ns = &#123; 1, 1, 2, 3, 5, 8 &#125;;for (int n : ns) &#123; System.out.print(n + &quot;, &quot;);&#125; 使用for each循环打印也很麻烦。幸好Java标准库提供了Arrays.toString()，可以快速打印数组内容： 12345678910// 遍历数组import java.util.Arrays;public class Main &#123; public static void main(String[] args) &#123; int[] ns = &#123; 1, 1, 2, 3, 5, 8 &#125;; System.out.println(Arrays.toString(ns)); &#125;&#125; 练习请按倒序遍历数组并打印每个元素： 123456789public class Main &#123; public static void main(String[] args) &#123; int[] ns = &#123; 1, 4, 9, 16, 25 &#125;; // 倒序打印数组元素: for (int i = ns.length-1; i&gt;=0; i--) &#123; System.out.println(ns[i]); &#125; &#125;&#125; 小结遍历数组可以使用for循环，for循环可以访问数组索引，for each循环直接迭代每个数组元素，但无法获取索引； 使用Arrays.toString()可以快速获取数组内容。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"01-Java快速入门","slug":"Java/01-Java快速入门","permalink":"http://example.com/categories/Java/01-Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"name":"--03-数组操作","slug":"Java/01-Java快速入门/03-数组操作","permalink":"http://example.com/categories/Java/01-Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/03-%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java-01-02-07-break和continue","slug":"liaoxuefeng/01-Java快速入门/02-流程控制/07-break和continue","date":"2020-08-01T23:00:00.000Z","updated":"2020-08-14T18:37:01.502Z","comments":true,"path":"2020/08/02/liaoxuefeng/01-Java快速入门/02-流程控制/07-break和continue/","link":"","permalink":"http://example.com/2020/08/02/liaoxuefeng/01-Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/02-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/07-break%E5%92%8Ccontinue/","excerpt":"","text":"无论是while循环还是for循环，有两个特别的语句可以使用，就是break语句和continue语句。 break在循环过程中，可以使用break语句跳出当前循环。我们来看一个例子： 1234567891011121314// breakpublic class Main &#123; public static void main(String[] args) &#123; int sum = 0; for (int i=1; ; i++) &#123; sum = sum + i; if (i == 100) &#123; break; &#125; &#125; System.out.println(sum); &#125;&#125; 使用for循环计算从1到100时，我们并没有在for()中设置循环退出的检测条件。但是，在循环内部，我们用if判断，如果i==100，就通过break退出循环。 因此，break语句通常都是配合if语句使用。要特别注意，break语句总是跳出自己所在的那一层循环。例如： 1234567891011121314151617// breakpublic class Main &#123; public static void main(String[] args) &#123; for (int i=1; i&lt;=10; i++) &#123; System.out.println(&quot;i = &quot; + i); for (int j=1; j&lt;=10; j++) &#123; System.out.println(&quot;j = &quot; + j); if (j &gt;= i) &#123; break; &#125; &#125; // break跳到这里 System.out.println(&quot;breaked&quot;); &#125; &#125;&#125; 上面的代码是两个for循环嵌套。因为break语句位于内层的for循环，因此，它会跳出内层for循环，但不会跳出外层for循环。 continuebreak会跳出当前循环，也就是整个循环都不会执行了。而continue则是提前结束本次循环，直接继续执行下次循环。我们看一个例子： 12345678910111213141516// continuepublic class Main &#123; public static void main(String[] args) &#123; int sum = 0; for (int i=1; i&lt;=10; i++) &#123; System.out.println(&quot;begin i = &quot; + i); if (i % 2 == 0) &#123; continue; // continue语句会结束本次循环 &#125; sum = sum + i; System.out.println(&quot;end i = &quot; + i); &#125; System.out.println(sum); // 25 &#125;&#125; 注意观察continue语句的效果。当i为奇数时，完整地执行了整个循环，因此，会打印begin i=1和end i=1。在i为偶数时，continue语句会提前结束本次循环，因此，会打印begin i=2但不会打印end i = 2。 在多层嵌套的循环中，continue语句同样是结束本次自己所在的循环。 小结break语句可以跳出当前循环； break语句通常配合if，在满足条件时提前结束整个循环； break语句总是跳出最近的一层循环； continue语句可以提前结束本次循环； continue语句通常配合if，在满足条件时提前结束本次循环。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"01-Java快速入门","slug":"Java/01-Java快速入门","permalink":"http://example.com/categories/Java/01-Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"name":"--02-流程控制","slug":"Java/01-Java快速入门/02-流程控制","permalink":"http://example.com/categories/Java/01-Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/02-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java-01-02-06-for循环","slug":"liaoxuefeng/01-Java快速入门/02-流程控制/06-for循环","date":"2020-08-01T22:00:00.000Z","updated":"2020-08-14T18:36:58.278Z","comments":true,"path":"2020/08/02/liaoxuefeng/01-Java快速入门/02-流程控制/06-for循环/","link":"","permalink":"http://example.com/2020/08/02/liaoxuefeng/01-Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/02-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/06-for%E5%BE%AA%E7%8E%AF/","excerpt":"","text":"除了while和do while循环，Java使用最广泛的是for循环。 for循环的功能非常强大，它使用计数器实现循环。for循环会先初始化计数器，然后，在每次循环前检测循环条件，在每次循环后更新计数器。计数器变量通常命名为i。 我们把1到100求和用for循环改写一下： 1234567891011// forpublic class Main &#123; public static void main(String[] args) &#123; int sum = 0; for (int i=1; i&lt;=100; i++) &#123; sum = sum + i; &#125; System.out.println(sum); &#125;&#125; 在for循环执行前，会先执行初始化语句int i=1，它定义了计数器变量i并赋初始值为1，然后，循环前先检查循环条件i&lt;=100，循环后自动执行i++，因此，和while循环相比，for循环把更新计数器的代码统一放到了一起。在for循环的循环体内部，不需要去更新变量i。 因此，for循环的用法是： 123for (初始条件; 循环检测条件; 循环后更新计数器) &#123; // 执行语句&#125; 如果我们要对一个整型数组的所有元素求和，可以用for循环实现： 12345678910111213// forpublic class Main &#123; public static void main(String[] args) &#123; int[] ns = &#123; 1, 4, 9, 16, 25 &#125;; int sum = 0; for (int i=0; i&lt;ns.length; i++) &#123; System.out.println(&quot;i = &quot; + i + &quot;, ns[i] = &quot; + ns[i]); sum = sum + ns[i]; &#125; System.out.println(&quot;sum = &quot; + sum); &#125;&#125; 上面代码的循环条件是i&lt;ns.length。因为ns数组的长度是5，因此，当循环5次后，i的值被更新为5，就不满足循环条件，因此for循环结束。 思考：如果把循环条件改为i&lt;=ns.length，会出现什么问题？ 注意for循环的初始化计数器总是会被执行，并且for循环也可能循环0次。 使用for循环时，千万不要在循环体内修改计数器！在循环体中修改计数器常常导致莫名其妙的逻辑错误。对于下面的代码： 1234567891011// forpublic class Main &#123; public static void main(String[] args) &#123; int[] ns = &#123; 1, 4, 9, 16, 25 &#125;; for (int i=0; i&lt;ns.length; i++) &#123; System.out.println(ns[i]); i = i + 1; &#125; &#125;&#125; 虽然不会报错，但是，数组元素只打印了一半，原因是循环内部的i = i + 1导致了计数器变量每次循环实际上加了2（因为for循环还会自动执行i++）。因此，在for循环中，不要修改计数器的值。计数器的初始化、判断条件、每次循环后的更新条件统一放到for()语句中可以一目了然。 如果希望只访问索引为奇数的数组元素，应该把for循环改写为： 1234int[] ns = &#123; 1, 4, 9, 16, 25 &#125;;for (int i=0; i&lt;ns.length; i=i+2) &#123; System.out.println(ns[i]);&#125; 通过更新计数器的语句i=i+2就达到了这个效果，从而避免了在循环体内去修改变量i。 使用for循环时，计数器变量i要尽量定义在for循环中： 123456int[] ns = &#123; 1, 4, 9, 16, 25 &#125;;for (int i=0; i&lt;ns.length; i++) &#123; System.out.println(ns[i]);&#125;// 无法访问iint n = i; // compile error! 如果变量i定义在for循环外： 1234567int[] ns = &#123; 1, 4, 9, 16, 25 &#125;;int i;for (i=0; i&lt;ns.length; i++) &#123; System.out.println(ns[i]);&#125;// 仍然可以使用iint n = i; 那么，退出for循环后，变量i仍然可以被访问，这就破坏了变量应该把访问范围缩到最小的原则。 灵活使用for循环for循环还可以缺少初始化语句、循环条件和每次循环更新语句，例如： 123456789101112// 不设置结束条件:for (int i=0; ; i++) &#123; ...&#125;// 不设置结束条件和更新语句:for (int i=0; ;) &#123; ...&#125;// 什么都不设置:for (;;) &#123; ...&#125; 通常不推荐这样写，但是，某些情况下，是可以省略for循环的某些语句的。 for each循环for循环经常用来遍历数组，因为通过计数器可以根据索引来访问数组的每个元素： 1234int[] ns = &#123; 1, 4, 9, 16, 25 &#125;;for (int i=0; i&lt;ns.length; i++) &#123; System.out.println(ns[i]);&#125; 但是，很多时候，我们实际上真正想要访问的是数组每个元素的值。Java还提供了另一种for each循环，它可以更简单地遍历数组： 12345678910// for eachpublic class Main &#123; public static void main(String[] args) &#123; int[] ns = &#123; 1, 4, 9, 16, 25 &#125;; for (int n : ns) &#123; System.out.println(n); &#125; &#125;&#125; 和for循环相比，for each循环的变量n不再是计数器，而是直接对应到数组的每个元素。for each循环的写法也更简洁。但是，for each循环无法指定遍历顺序，也无法获取数组的索引。 除了数组外，for each循环能够遍历所有“可迭代”的数据类型，包括后面会介绍的List、Map等。 练习1给定一个数组，请用for循环倒序输出每一个元素： 12345678910// forpublic class Main &#123; public static void main(String[] args) &#123; int[] ns = &#123;1, 4, 9, 16, 25&#125;; for (int i = ns.length - 1; i &gt;= 0; i--) &#123; System.out.println(ns[i]); &#125; &#125;&#125; 练习2利用for each循环对数组每个元素求和： 123456789101112// for eachpublic class Main &#123; public static void main(String[] args) &#123; int[] ns = &#123;1, 4, 9, 16, 25&#125;; int sum = 0; for (int n : ns) &#123; sum += n; &#125; System.out.println(sum); // 55 &#125;&#125; 练习3圆周率π可以使用公式计算： $\\frac{\\mathrm\\pi}4=1-\\frac13+\\frac15-\\frac17+\\frac19-\\dots$ 请利用for循环计算π： 123456789101112// forpublic class Main &#123; public static void main(String[] args) &#123; double pi = 0; for (int i = 1, sign = 1; i &lt; 1000000000; i += 2) &#123; pi += 1.0 / i * sign; sign *= -1; &#125; System.out.println(&quot;π = &quot; + 4 * pi); &#125;&#125; 小结for循环通过计数器可以实现复杂循环； for each循环可以直接遍历数组的每个元素； 最佳实践：计数器变量定义在for循环内部，循环体内部不修改计数器；","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"01-Java快速入门","slug":"Java/01-Java快速入门","permalink":"http://example.com/categories/Java/01-Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"name":"--02-流程控制","slug":"Java/01-Java快速入门/02-流程控制","permalink":"http://example.com/categories/Java/01-Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/02-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java-01-02-05-do while循环","slug":"liaoxuefeng/01-Java快速入门/02-流程控制/05-do while循环","date":"2020-08-01T21:00:00.000Z","updated":"2020-08-14T18:36:54.997Z","comments":true,"path":"2020/08/02/liaoxuefeng/01-Java快速入门/02-流程控制/05-do while循环/","link":"","permalink":"http://example.com/2020/08/02/liaoxuefeng/01-Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/02-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/05-do%20while%E5%BE%AA%E7%8E%AF/","excerpt":"","text":"在Java中，while循环是先判断循环条件，再执行循环。而另一种do while循环则是先执行循环，再判断条件，条件满足时继续循环，条件不满足时退出。它的用法是： 123do &#123; 执行循环语句&#125; while (条件表达式); 可见，do while循环会至少循环一次。 我们把对1到100的求和用do while循环改写一下： 12345678910111213// do-whilepublic class Main &#123; public static void main(String[] args) &#123; int sum = 0; int n = 1; do &#123; sum = sum + n; n ++; &#125; while (n &lt;= 100); System.out.println(sum); &#125;&#125; 使用do while循环时，同样要注意循环条件的判断。 练习使用do while循环计算从m到n的和。 1234567891011121314151617// do whilepublic class Main &#123; public static void main(String[] args) &#123; int sum = 0; int m = 20; int n = 100; // 使用do while计算M+...+N: do &#123; sum += m; m++; &#125; while (m&lt;=n); System.out.println(sum); &#125;&#125; 小结do while循环先执行循环，再判断条件； do while循环会至少执行一次。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"01-Java快速入门","slug":"Java/01-Java快速入门","permalink":"http://example.com/categories/Java/01-Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"name":"--02-流程控制","slug":"Java/01-Java快速入门/02-流程控制","permalink":"http://example.com/categories/Java/01-Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/02-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java-01-02-04-while循环","slug":"liaoxuefeng/01-Java快速入门/02-流程控制/04-while循环","date":"2020-08-01T20:00:00.000Z","updated":"2020-08-14T18:36:51.389Z","comments":true,"path":"2020/08/02/liaoxuefeng/01-Java快速入门/02-流程控制/04-while循环/","link":"","permalink":"http://example.com/2020/08/02/liaoxuefeng/01-Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/02-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/04-while%E5%BE%AA%E7%8E%AF/","excerpt":"","text":"循环语句就是让计算机根据条件做循环计算，在条件满足时继续循环，条件不满足时退出循环。 例如，计算从1到100的和： 11 + 2 + 3 + 4 + … + 100 = ? 除了用数列公式外，完全可以让计算机做100次循环累加。因为计算机的特点是计算速度非常快，我们让计算机循环一亿次也用不到1秒，所以很多计算的任务，人去算是算不了的，但是计算机算，使用循环这种简单粗暴的方法就可以快速得到结果。 我们先看Java提供的while条件循环。它的基本用法是： 1234while (条件表达式) &#123; 循环语句&#125;// 继续执行后续代码 while循环在每次循环开始前，首先判断条件是否成立。如果计算结果为true，就把循环体内的语句执行一遍，如果计算结果为false，那就直接跳到while循环的末尾，继续往下执行。 我们用while循环来累加1到100，可以这么写： 12345678910111213// whilepublic class Main &#123; public static void main(String[] args) &#123; int sum = 0; // 累加的和，初始化为0 int n = 1; while (n &lt;= 100) &#123; // 循环条件是n &lt;= 100 sum = sum + n; // 把n累加到sum中 n ++; // n自身加1 &#125; System.out.println(sum); // 5050 &#125;&#125; 注意到while循环是先判断循环条件，再循环，因此，有可能一次循环都不做。 对于循环条件判断，以及自增变量的处理，要特别注意边界条件。思考一下下面的代码为何没有获得正确结果： 12345678910111213// whilepublic class Main &#123; public static void main(String[] args) &#123; int sum = 0; int n = 0; while (n &lt;= 100) &#123; n ++; // 最后一次循环，此处n自加变成了101 sum = sum + n; &#125; System.out.println(sum); &#125;&#125; 如果循环条件永远满足，那这个循环就变成了死循环。死循环将导致100%的CPU占用，用户会感觉电脑运行缓慢，所以要避免编写死循环代码。 如果循环条件的逻辑写得有问题，也会造成意料之外的结果： 1234567891011121314// whilepublic class Main &#123; public static void main(String[] args) &#123; int sum = 0; int n = 1; while (n &gt; 0) &#123; sum = sum + n; n ++; &#125; System.out.println(n); // -2147483648 System.out.println(sum); &#125;&#125; 表面上看，上面的while循环是一个死循环，但是，Java的int类型有最大值，达到最大值后，再加1会变成负数，结果，意外退出了while循环。 练习使用while计算从m到n的和： 123456789101112131415161718/** * while练习 */public class Main &#123; public static void main(String[] args) &#123; int sum = 0; int m = 20; int n = 100; // FIXME: 使用while计算M+...+N: while (m &lt;= n) &#123; sum += m; m++; &#125; System.out.println(sum); &#125;&#125; 小结while循环先判断循环条件是否满足，再执行循环语句； while循环可能一次都不执行； 编写循环时要注意循环条件，并避免死循环。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"01-Java快速入门","slug":"Java/01-Java快速入门","permalink":"http://example.com/categories/Java/01-Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"name":"--02-流程控制","slug":"Java/01-Java快速入门/02-流程控制","permalink":"http://example.com/categories/Java/01-Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/02-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java-01-02-03-switch多重选择","slug":"liaoxuefeng/01-Java快速入门/02-流程控制/03-switch多重选择","date":"2020-08-01T19:00:00.000Z","updated":"2020-08-14T18:36:48.021Z","comments":true,"path":"2020/08/02/liaoxuefeng/01-Java快速入门/02-流程控制/03-switch多重选择/","link":"","permalink":"http://example.com/2020/08/02/liaoxuefeng/01-Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/02-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/03-switch%E5%A4%9A%E9%87%8D%E9%80%89%E6%8B%A9/","excerpt":"","text":"除了if语句外，还有一种条件判断，是根据某个表达式的结果，分别去执行不同的分支。 例如，在游戏中，让用户选择选项： 单人模式 多人模式 退出游戏 这时，switch语句就派上用场了。 switch语句根据switch (表达式)计算的结果，跳转到匹配的case结果，然后继续执行后续语句，直到遇到break结束执行。 我们看一个例子： 123456789101112131415161718// switchpublic class Main &#123; public static void main(String[] args) &#123; int option = 1; switch (option) &#123; case 1: System.out.println(&quot;Selected 1&quot;); break; case 2: System.out.println(&quot;Selected 2&quot;); break; case 3: System.out.println(&quot;Selected 3&quot;); break; &#125; &#125;&#125; 修改option的值分别为1、2、3，观察执行结果。 如果option的值没有匹配到任何case，例如option = 99，那么，switch语句不会执行任何语句。这时，可以给switch语句加一个default，当没有匹配到任何case时，执行default： 123456789101112131415161718192021// switchpublic class Main &#123; public static void main(String[] args) &#123; int option = 99; switch (option) &#123; case 1: System.out.println(&quot;Selected 1&quot;); break; case 2: System.out.println(&quot;Selected 2&quot;); break; case 3: System.out.println(&quot;Selected 3&quot;); break; default: System.out.println(&quot;Not selected&quot;); break; &#125; &#125;&#125; 如果把switch语句翻译成if语句，那么上述的代码相当于： 123456789if (option == 1) &#123; System.out.println(&quot;Selected 1&quot;);&#125; else if (option == 2) &#123; System.out.println(&quot;Selected 2&quot;);&#125; else if (option == 3) &#123; System.out.println(&quot;Selected 3&quot;);&#125; else &#123; System.out.println(&quot;Not selected&quot;);&#125; 对于多个==判断的情况，使用switch结构更加清晰。 同时注意，上述“翻译”只有在switch语句中对每个case正确编写了break语句才能对应得上。 使用switch时，注意case语句并没有花括号&#123;&#125;，而且，case语句具有“穿透性”，漏写break将导致意想不到的结果： 1234567891011121314151617// switchpublic class Main &#123; public static void main(String[] args) &#123; int option = 2; switch (option) &#123; case 1: System.out.println(&quot;Selected 1&quot;); case 2: System.out.println(&quot;Selected 2&quot;); case 3: System.out.println(&quot;Selected 3&quot;); default: System.out.println(&quot;Not selected&quot;); &#125; &#125;&#125; 当option = 2时，将依次输出&quot;Selected 2&quot;、&quot;Selected 3&quot;、&quot;Not selected&quot;，原因是从匹配到case 2开始，后续语句将全部执行，直到遇到break语句。因此，任何时候都不要忘记写break。 如果有几个case语句执行的是同一组语句块，可以这么写： 12345678910111213141516171819// switchpublic class Main &#123; public static void main(String[] args) &#123; int option = 2; switch (option) &#123; case 1: System.out.println(&quot;Selected 1&quot;); break; case 2: case 3: System.out.println(&quot;Selected 2, 3&quot;); break; default: System.out.println(&quot;Not selected&quot;); break; &#125; &#125;&#125; 使用switch语句时，只要保证有break，case的顺序不影响程序逻辑： 1234567891011switch (option) &#123;case 3: ... break;case 2: ... break;case 1: ... break;&#125; 但是仍然建议按照自然顺序排列，便于阅读。 switch语句还可以匹配字符串。字符串匹配时，是比较“内容相等”。例如： 123456789101112131415161718192021// switchpublic class Main &#123; public static void main(String[] args) &#123; String fruit = &quot;apple&quot;; switch (fruit) &#123; case &quot;apple&quot;: System.out.println(&quot;Selected apple&quot;); break; case &quot;pear&quot;: System.out.println(&quot;Selected pear&quot;); break; case &quot;mango&quot;: System.out.println(&quot;Selected mango&quot;); break; default: System.out.println(&quot;No fruit selected&quot;); break; &#125; &#125;&#125; switch语句还可以使用枚举类型，枚举类型我们在后面讲解。 编译检查使用IDE时，可以自动检查是否漏写了break语句和default语句，方法是打开IDE的编译检查。 在Eclipse中，选择Preferences - Java - Compiler - Errors/Warnings - Potential programming problems，将以下检查标记为Warning： ‘switch’ is missing ‘default’ case ‘switch’ case fall-through 在Idea中，选择Preferences - Editor - Inspections - Java - Control flow issues，将以下检查标记为Warning： Fallthrough in ‘switch’ statement ‘switch’ statement without ‘default’ branch 当switch语句存在问题时，即可在IDE中获得警告提示。 switch表达式使用switch时，如果遗漏了break，就会造成严重的逻辑错误，而且不易在源代码中发现错误。从Java 12开始，switch语句升级为更简洁的表达式语法，使用类似模式匹配（Pattern Matching）的方法，保证只有一种路径会被执行，并且不需要break语句： 12345678910111213141516// switchpublic class Main &#123; public static void main(String[] args) &#123; String fruit = &quot;apple&quot;; switch (fruit) &#123; case &quot;apple&quot; -&gt; System.out.println(&quot;Selected apple&quot;); case &quot;pear&quot; -&gt; System.out.println(&quot;Selected pear&quot;); case &quot;mango&quot; -&gt; &#123; System.out.println(&quot;Selected mango&quot;); System.out.println(&quot;Good choice!&quot;); &#125; default -&gt; System.out.println(&quot;No fruit selected&quot;); &#125; &#125;&#125; 注意新语法使用-&gt;，如果有多条语句，需要用&#123;&#125;括起来。不要写break语句，因为新语法只会执行匹配的语句，没有穿透效应。 很多时候，我们还可能用switch语句给某个变量赋值。例如： 12345678910111213int opt;switch (fruit) &#123;case &quot;apple&quot;: opt = 1; break;case &quot;pear&quot;:case &quot;mango&quot;: opt = 2; break;default: opt = 0; break;&#125; 使用新的switch语法，不但不需要break，还可以直接返回值。把上面的代码改写如下： 12345678910111213// switchpublic class Main &#123; public static void main(String[] args) &#123; String fruit = &quot;apple&quot;; int opt = switch (fruit) &#123; case &quot;apple&quot; -&gt; 1; case &quot;pear&quot;, &quot;mango&quot; -&gt; 2; default -&gt; 0; &#125;; // 注意赋值语句要以;结束 System.out.println(&quot;opt = &quot; + opt); &#125;&#125; 这样可以获得更简洁的代码。 yield大多数时候，在switch表达式内部，我们会返回简单的值。 但是，如果需要复杂的语句，我们也可以写很多语句，放到&#123;...&#125;里，然后，用yield返回一个值作为switch语句的返回值： 12345678910111213141516// yieldpublic class Main &#123; public static void main(String[] args) &#123; String fruit = &quot;orange&quot;; int opt = switch (fruit) &#123; case &quot;apple&quot; -&gt; 1; case &quot;pear&quot;, &quot;mango&quot; -&gt; 2; default -&gt; &#123; int code = fruit.hashCode(); yield code; // switch语句返回值 &#125; &#125;; System.out.println(&quot;opt = &quot; + opt); &#125;&#125; 练习使用switch实现一个简单的石头、剪子、布游戏。 123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.Scanner;/** * switch实现石头/剪子/布并判断胜负 */public class Main &#123; public static void main(String[] args) &#123; // 系统提示 System.out.println(&quot;please choice:&quot;); System.out.println(&quot; 1: Rock&quot;); System.out.println(&quot; 2: Scissors&quot;); System.out.println(&quot; 3: Paper&quot;); // 用户输入: Scanner scanner = new Scanner(System.in); int choice = scanner.nextInt(); // 计算机随机数 1, 2, 3: int random = 1 + (int) Math.random() * 3; // 输出系统选择 System.out.println(&quot;System choose &quot; + switch (random) &#123; case 1 -&gt; &quot;rock&quot;; case 2 -&gt; &quot;scissors&quot;; case 3 -&gt; &quot;paper&quot;; default -&gt; &quot;系统出现错误&quot;; &#125;); // 输出结果 String result = switch (choice) &#123; case 1 -&gt; random == choice ? &quot;平局&quot; : (random == 2 ? &quot;你赢了&quot; : &quot;你输了&quot;); case 2 -&gt; random == choice ? &quot;平局&quot; : (random == 1 ? &quot;你输了&quot; : &quot;你赢了&quot;); case 3 -&gt; random == choice ? &quot;平局&quot; : (random == 1 ? &quot;你赢了&quot; : &quot;你输了&quot;); default -&gt; &quot;你的输入有误&quot;; &#125;; System.out.println(result); &#125;&#125; 小结switch语句可以做多重选择，然后执行匹配的case语句后续代码； switch的计算结果必须是整型、字符串或枚举类型； 注意千万不要漏写break，建议打开fall-through警告； 总是写上default，建议打开missing default警告； 从Java 14开始，switch语句正式升级为表达式，不再需要break，并且允许使用yield返回值。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"01-Java快速入门","slug":"Java/01-Java快速入门","permalink":"http://example.com/categories/Java/01-Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"name":"--02-流程控制","slug":"Java/01-Java快速入门/02-流程控制","permalink":"http://example.com/categories/Java/01-Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/02-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java-01-02-02-if判断","slug":"liaoxuefeng/01-Java快速入门/02-流程控制/02-if判断","date":"2020-08-01T18:00:00.000Z","updated":"2020-08-14T18:36:44.745Z","comments":true,"path":"2020/08/02/liaoxuefeng/01-Java快速入门/02-流程控制/02-if判断/","link":"","permalink":"http://example.com/2020/08/02/liaoxuefeng/01-Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/02-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/02-if%E5%88%A4%E6%96%AD/","excerpt":"","text":"在Java程序中，如果要根据条件来决定是否执行某一段代码，就需要if语句。 if语句的基本语法是： 123if (条件) &#123; // 条件满足时执行&#125; 根据if的计算结果（true还是false），JVM决定是否执行if语句块（即花括号{}包含的所有语句）。 让我们来看一个例子： 1234567891011// 条件判断public class Main &#123; public static void main(String[] args) &#123; int n = 70; if (n &gt;= 60) &#123; System.out.println(&quot;及格了&quot;); &#125; System.out.println(&quot;END&quot;); &#125;&#125; 当条件n &gt;= 60计算结果为true时，if语句块被执行，将打印&quot;及格了&quot;，否则，if语句块将被跳过。修改n的值可以看到执行效果。 注意到if语句包含的块可以包含多条语句： 123456789101112// 条件判断public class Main &#123; public static void main(String[] args) &#123; int n = 70; if (n &gt;= 60) &#123; System.out.println(&quot;及格了&quot;); System.out.println(&quot;恭喜你&quot;); &#125; System.out.println(&quot;END&quot;); &#125;&#125; 当if语句块只有一行语句时，可以省略花括号{}： 12345678910// 条件判断public class Main &#123; public static void main(String[] args) &#123; int n = 70; if (n &gt;= 60) System.out.println(&quot;及格了&quot;); System.out.println(&quot;END&quot;); &#125;&#125; 但是，省略花括号并不总是一个好主意。假设某个时候，突然想给if语句块增加一条语句时： 1234567891011// 条件判断public class Main &#123; public static void main(String[] args) &#123; int n = 50; if (n &gt;= 60) System.out.println(&quot;及格了&quot;); System.out.println(&quot;恭喜你&quot;); // 注意这条语句不是if语句块的一部分 System.out.println(&quot;END&quot;); &#125;&#125; 由于使用缩进格式，很容易把两行语句都看成if语句的执行块，但实际上只有第一行语句是if的执行块。在使用git这些版本控制系统自动合并时更容易出问题，所以不推荐忽略花括号的写法。 elseif语句还可以编写一个else &#123; ... &#125;，当条件判断为false时，将执行else的语句块： 12345678910111213// 条件判断public class Main &#123; public static void main(String[] args) &#123; int n = 70; if (n &gt;= 60) &#123; System.out.println(&quot;及格了&quot;); &#125; else &#123; System.out.println(&quot;挂科了&quot;); &#125; System.out.println(&quot;END&quot;); &#125;&#125; 修改上述代码n的值，观察if条件为true或false时，程序执行的语句块。 注意，else不是必须的。 还可以用多个if ... else if ...串联。例如： 123456789101112131415// 条件判断public class Main &#123; public static void main(String[] args) &#123; int n = 70; if (n &gt;= 90) &#123; System.out.println(&quot;优秀&quot;); &#125; else if (n &gt;= 60) &#123; System.out.println(&quot;及格了&quot;); &#125; else &#123; System.out.println(&quot;挂科了&quot;); &#125; System.out.println(&quot;END&quot;); &#125;&#125; 串联的效果其实相当于： 12345678910111213if (n &gt;= 90) &#123; // n &gt;= 90为true: System.out.println(&quot;优秀&quot;);&#125; else &#123; // n &gt;= 90为false: if (n &gt;= 60) &#123; // n &gt;= 60为true: System.out.println(&quot;及格了&quot;); &#125; else &#123; // n &gt;= 60为false: System.out.println(&quot;挂科了&quot;); &#125;&#125; 在串联使用多个if时，要特别注意判断顺序。观察下面的代码： 1234567891011121314// 条件判断public class Main &#123; public static void main(String[] args) &#123; int n = 100; if (n &gt;= 60) &#123; System.out.println(&quot;及格了&quot;); &#125; else if (n &gt;= 90) &#123; System.out.println(&quot;优秀&quot;); &#125; else &#123; System.out.println(&quot;挂科了&quot;); &#125; &#125;&#125; 执行发现，n = 100时，满足条件n &gt;= 90，但输出的不是&quot;优秀&quot;，而是&quot;及格了&quot;，原因是if语句从上到下执行时，先判断n &gt;= 60成功后，后续else不再执行，因此，if (n &gt;= 90)没有机会执行了。 正确的方式是按照判断范围从大到小依次判断： 12345678// 从大到小依次判断：if (n &gt;= 90) &#123; // ...&#125; else if (n &gt;= 60) &#123; // ...&#125; else &#123; // ...&#125; 或者改写成从小到大依次判断： 12345678// 从小到大依次判断：if (n &lt; 60) &#123; // ...&#125; else if (n &lt; 90) &#123; // ...&#125; else &#123; // ...&#125; 使用if时，还要特别注意边界条件。例如： 1234567891011121314// 条件判断public class Main &#123; public static void main(String[] args) &#123; int n = 90; if (n &gt; 90) &#123; System.out.println(&quot;优秀&quot;); &#125; else if (n &gt;= 60) &#123; System.out.println(&quot;及格了&quot;); &#125; else &#123; System.out.println(&quot;挂科了&quot;); &#125; &#125;&#125; 假设我们期望90分或更高为“优秀”，上述代码输出的却是“及格”，原因是&gt;和&gt;=效果是不同的。 前面讲过了浮点数在计算机中常常无法精确表示，并且计算可能出现误差，因此，判断浮点数相等用==判断不靠谱： 123456789101112// 条件判断public class Main &#123; public static void main(String[] args) &#123; double x = 1 - 9.0 / 10; if (x == 0.1) &#123; System.out.println(&quot;x is 0.1&quot;); &#125; else &#123; System.out.println(&quot;x is NOT 0.1&quot;); &#125; &#125;&#125; 正确的方法是利用差值小于某个临界值来判断： 123456789101112// 条件判断public class Main &#123; public static void main(String[] args) &#123; double x = 1 - 9.0 / 10; if (Math.abs(x - 0.1) &lt; 0.00001) &#123; System.out.println(&quot;x is 0.1&quot;); &#125; else &#123; System.out.println(&quot;x is NOT 0.1&quot;); &#125; &#125;&#125; 判断引用类型相等在Java中，判断值类型的变量是否相等，可以使用==运算符。但是，判断引用类型的变量是否相等，==表示“引用是否相等”，或者说，是否指向同一个对象。例如，下面的两个String类型，它们的内容是相同的，但是，分别指向不同的对象，用==判断，结果为false： 123456789101112131415// 条件判断public class Main &#123; public static void main(String[] args) &#123; String s1 = &quot;hello&quot;; String s2 = &quot;HELLO&quot;.toLowerCase(); System.out.println(s1); System.out.println(s2); if (s1 == s2) &#123; System.out.println(&quot;s1 == s2&quot;); &#125; else &#123; System.out.println(&quot;s1 != s2&quot;); &#125; &#125;&#125; 要判断引用类型的变量内容是否相等，必须使用equals()方法： 123456789101112131415// 条件判断public class Main &#123; public static void main(String[] args) &#123; String s1 = &quot;hello&quot;; String s2 = &quot;HELLO&quot;.toLowerCase(); System.out.println(s1); System.out.println(s2); if (s1.equals(s2)) &#123; System.out.println(&quot;s1 equals s2&quot;); &#125; else &#123; System.out.println(&quot;s1 not equals s2&quot;); &#125; &#125;&#125; 注意：执行语句s1.equals(s2)时，如果变量s1为null，会报NullPointerException： 12345678910// 条件判断public class Main &#123; public static void main(String[] args) &#123; String s1 = null; if (s1.equals(&quot;hello&quot;)) &#123; System.out.println(&quot;hello&quot;); &#125; &#125;&#125; 要避免NullPointerException错误，可以利用短路运算符&amp;&amp;： 12345678public class Main &#123; public static void main(String[] args) &#123; String s1 = null; if (s1 != null &amp;&amp; s1.equals(&quot;hello&quot;)) &#123; System.out.println(&quot;hello&quot;); &#125; &#125;&#125; 还可以把一定不是null的对象&quot;hello&quot;放到前面：例如：if (&quot;hello&quot;.equals(s)) &#123; ... &#125;。 练习请用if ... else编写一个程序，用于计算体质指数BMI，并打印结果。 BMI = 体重(kg)除以身高(m)的平方 BMI结果： 过轻：低于18.5 正常：18.5-25 过重：25-28 肥胖：28-32 非常肥胖：高于32 1234567891011121314151617181920212223242526272829303132import java.util.Scanner;/** * 计算BMI */public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); System.out.print(&quot;Height (m): &quot;); double height = scanner.nextDouble(); System.out.print(&quot;Weight (kg): &quot;); double weight = scanner.nextDouble(); double bmi = weight / (height * height); System.out.printf(&quot;BMI: %.2f \\n&quot;, bmi); if (bmi &gt; 32) &#123; System.out.println(&quot;非常肥胖&quot;); &#125; else if (bmi &gt; 28 &amp;&amp; bmi &lt;= 32) &#123; System.out.println(&quot;肥胖&quot;); &#125; else if (bmi &gt; 25 &amp;&amp; bmi &lt;= 28) &#123; System.out.println(&quot;过重&quot;); &#125; else if (bmi &gt; 18.5 &amp;&amp; bmi &lt;= 25) &#123; System.out.println(&quot;正常&quot;); &#125; else &#123; System.out.println(&quot;过轻&quot;); &#125; &#125;&#125; 小结if ... else可以做条件判断，else是可选的； 不推荐省略花括号&#123;&#125;； 多个if ... else串联要特别注意判断顺序； 要注意if的边界条件； 要注意浮点数判断相等不能直接用==运算符； 引用类型判断内容相等要使用equals()，注意避免NullPointerException。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"01-Java快速入门","slug":"Java/01-Java快速入门","permalink":"http://example.com/categories/Java/01-Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"name":"--02-流程控制","slug":"Java/01-Java快速入门/02-流程控制","permalink":"http://example.com/categories/Java/01-Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/02-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java-01-02-01-输入和输出","slug":"liaoxuefeng/01-Java快速入门/02-流程控制/01-输入和输出","date":"2020-08-01T17:00:00.000Z","updated":"2020-08-14T18:36:41.986Z","comments":true,"path":"2020/08/02/liaoxuefeng/01-Java快速入门/02-流程控制/01-输入和输出/","link":"","permalink":"http://example.com/2020/08/02/liaoxuefeng/01-Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/02-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/01-%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA/","excerpt":"","text":"输出在前面的代码中，我们总是使用System.out.println()来向屏幕输出一些内容。 println是print line的缩写，表示输出并换行。因此，如果输出后不想换行，可以用print()： 1234567891011// 输出public class Main &#123; public static void main(String[] args) &#123; System.out.print(&quot;A,&quot;); System.out.print(&quot;B,&quot;); System.out.print(&quot;C.&quot;); System.out.println(); System.out.println(&quot;END&quot;); &#125;&#125; 注意观察上述代码的执行效果。 格式化输出Java还提供了格式化输出的功能。为什么要格式化输出？因为计算机表示的数据不一定适合人来阅读： 12345678// 格式化输出public class Main &#123; public static void main(String[] args) &#123; double d = 12900000; System.out.println(d); // 1.29E7 &#125;&#125; 如果要把数据显示成我们期望的格式，就需要使用格式化输出的功能。格式化输出使用System.out.printf()，通过使用占位符%?，printf()可以把后面的参数格式化成指定格式： 123456789// 格式化输出public class Main &#123; public static void main(String[] args) &#123; double d = 3.1415926; System.out.printf(&quot;%.2f\\n&quot;, d); // 显示两位小数3.14 System.out.printf(&quot;%.4f\\n&quot;, d); // 显示4位小数3.1416 &#125;&#125; Java的格式化功能提供了多种占位符，可以把各种数据类型“格式化”成指定的字符串： 占位符 说明 %d 格式化输出整数 %x 格式化输出十六进制整数 %f 格式化输出浮点数 %e 格式化输出科学计数法表示的浮点数 %s 格式化字符串 注意，由于%表示占位符，因此，连续两个%%表示一个%字符本身。 占位符本身还可以有更详细的格式化参数。下面的例子把一个整数格式化成十六进制，并用0补足8位： 12345678// 格式化输出public class Main &#123; public static void main(String[] args) &#123; int n = 12345000; System.out.printf(&quot;n=%d, hex=%08x&quot;, n, n); // 注意，两个%占位符必须传入两个数 &#125;&#125; 详细的格式化参数请参考JDK文档java.util.Formatter 输入和输出相比，Java的输入就要复杂得多。 我们先看一个从控制台读取一个字符串和一个整数的例子： 123456789101112import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); // 创建Scanner对象 System.out.print(&quot;Input your name: &quot;); // 打印提示 String name = scanner.nextLine(); // 读取一行输入并获取字符串 System.out.print(&quot;Input your age: &quot;); // 打印提示 int age = scanner.nextInt(); // 读取一行输入并获取整数 System.out.printf(&quot;Hi, %s, you are %d\\n&quot;, name, age); // 格式化输出 &#125;&#125; 首先，我们通过import语句导入java.util.Scanner，import是导入某个类的语句，必须放到Java源代码的开头，后面我们在Java的package中会详细讲解如何使用import。 然后，创建Scanner对象并传入System.in。System.out代表标准输出流，而System.in代表标准输入流。直接使用System.in读取用户输入虽然是可以的，但需要更复杂的代码，而通过Scanner就可以简化后续的代码。 有了Scanner对象后，要读取用户输入的字符串，使用scanner.nextLine()，要读取用户输入的整数，使用scanner.nextInt()。Scanner会自动转换数据类型，因此不必手动转换。 要测试输入，我们不能在线运行它，因为输入必须从命令行读取，因此，需要走编译、执行的流程： 1$ javac Main.java 这个程序编译时如果有警告，可以暂时忽略它，在后面学习IO的时候再详细解释。编译成功后，执行： 1234$ java MainInput your name: BobInput your age: 12Hi, Bob, you are 12 根据提示分别输入一个字符串和整数后，我们得到了格式化的输出。 练习请帮小明同学设计一个程序，输入上次考试成绩（int）和本次考试成绩（int），然后输出成绩提高的百分比，保留两位小数位（例如，21.75%）。 12345678910111213141516171819import java.util.Scanner;/** * 输入上次考试成绩（int）和本次考试成绩（int），然后输出成绩提高的百分比，保留两位小数位（例如，21.75%） */public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); System.out.println(&quot;请输入上次考试成绩：&quot;); int prev = scanner.nextInt(); System.out.println(&quot;请输入此次考试成绩：&quot;); int score = scanner.nextInt(); double percent = (double)(score - prev) / prev; System.out.printf(&quot;成绩提高了%.2f%%&quot;, percent*100); &#125;&#125; 小结Java提供的输出包括：System.out.println() / print() / printf()，其中printf()可以格式化输出； Java提供Scanner对象来方便输入，读取对应的类型可以使用：scanner.nextLine() / nextInt() / nextDouble() / …","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"01-Java快速入门","slug":"Java/01-Java快速入门","permalink":"http://example.com/categories/Java/01-Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"name":"--02-流程控制","slug":"Java/01-Java快速入门/02-流程控制","permalink":"http://example.com/categories/Java/01-Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/02-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java-01-01-07-数组类型","slug":"liaoxuefeng/01-Java快速入门/01-Java程序基础/07-数组类型","date":"2020-07-31T23:00:00.000Z","updated":"2020-08-14T18:36:37.978Z","comments":true,"path":"2020/08/01/liaoxuefeng/01-Java快速入门/01-Java程序基础/07-数组类型/","link":"","permalink":"http://example.com/2020/08/01/liaoxuefeng/01-Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/01-Java%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/07-%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"如果我们有一组类型相同的变量，例如，5位同学的成绩，可以这么写： 12345678910public class Main &#123; public static void main(String[] args) &#123; // 5位同学的成绩: int n1 = 68; int n2 = 79; int n3 = 91; int n4 = 85; int n5 = 62; &#125;&#125; 但其实没有必要定义5个int变量。可以使用数组来表示“一组”int类型。代码如下： 12345678910111213// 数组public class Main &#123; public static void main(String[] args) &#123; // 5位同学的成绩: int[] ns = new int[5]; ns[0] = 68; ns[1] = 79; ns[2] = 91; ns[3] = 85; ns[4] = 62; &#125;&#125; 定义一个数组类型的变量，使用数组类型“类型[]”，例如，int[]。和单个基本类型变量不同，数组变量初始化必须使用new int[5]表示创建一个可容纳5个int元素的数组。 Java的数组有几个特点： 数组所有元素初始化为默认值，整型都是0，浮点型是0.0，布尔型是false； 数组一旦创建后，大小就不可改变。 要访问数组中的某一个元素，需要使用索引。数组索引从0开始，例如，5个元素的数组，索引范围是0 ~ 4。 可以修改数组中的某一个元素，使用赋值语句，例如，ns[1] = 79;。 可以用数组变量.length获取数组大小： 123456789// 数组public class Main &#123; public static void main(String[] args) &#123; // 5位同学的成绩: int[] ns = new int[5]; System.out.println(ns.length); // 5 &#125;&#125; 数组是引用类型，在使用索引访问数组元素时，如果索引超出范围，运行时将报错： 12345678910// 数组public class Main &#123; public static void main(String[] args) &#123; // 5位同学的成绩: int[] ns = new int[5]; int n = 5; System.out.println(ns[n]); // 索引n不能超出范围 &#125;&#125; 也可以在定义数组时直接指定初始化的元素，这样就不必写出数组大小，而是由编译器自动推算数组大小。例如： 123456789// 数组public class Main &#123; public static void main(String[] args) &#123; // 5位同学的成绩: int[] ns = new int[] &#123; 68, 79, 91, 85, 62 &#125;; System.out.println(ns.length); // 编译器自动推算数组大小为5 &#125;&#125; 还可以进一步简写为： 1int[] ns = &#123; 68, 79, 91, 85, 62 &#125;; 注意数组是引用类型，并且数组大小不可变。我们观察下面的代码： 123456789101112// 数组public class Main &#123; public static void main(String[] args) &#123; // 5位同学的成绩: int[] ns; ns = new int[] &#123; 68, 79, 91, 85, 62 &#125;; System.out.println(ns.length); // 5 ns = new int[] &#123; 1, 2, 3 &#125;; System.out.println(ns.length); // 3 &#125;&#125; 数组大小变了吗？看上去好像是变了，但其实根本没变。 对于数组ns来说，执行ns = new int[] &#123; 68, 79, 91, 85, 62 &#125;;时，它指向一个5个元素的数组： 123456 ns │ ▼┌───┬───┬───┬───┬───┬───┬───┐│ │68 │79 │91 │85 │62 │ │└───┴───┴───┴───┴───┴───┴───┘ 执行ns = new int[] &#123; 1, 2, 3 &#125;;时，它指向一个新的3个元素的数组： 123456 ns ──────────────────────┐ │ ▼┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐│ │68 │79 │91 │85 │62 │ │ 1 │ 2 │ 3 │ │└───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘ 但是，原有的5个元素的数组并没有改变，只是无法通过变量ns引用到它们而已。 字符串数组如果数组元素不是基本类型，而是一个引用类型，那么，修改数组元素会有哪些不同？ 字符串是引用类型，因此我们先定义一个字符串数组： 123String[] names = &#123; &quot;ABC&quot;, &quot;XYZ&quot;, &quot;zoo&quot;&#125;; 对于String[]类型的数组变量names，它实际上包含3个元素，但每个元素都指向某个字符串对象： 123456789 ┌─────────────────────────┐ names │ ┌─────────────────────┼───────────┐ │ │ │ │ │ ▼ │ │ ▼ ▼┌───┬───┬─┴─┬─┴─┬───┬───────┬───┬───────┬───┬───────┬───┐│ │░░░│░░░│░░░│ │ &quot;ABC&quot; │ │ &quot;XYZ&quot; │ │ &quot;zoo&quot; │ │└───┴─┬─┴───┴───┴───┴───────┴───┴───────┴───┴───────┴───┘ │ ▲ └─────────────────┘ 对names[1]进行赋值，例如names[1] = &quot;cat&quot;;，效果如下： 123456789 ┌─────────────────────────────────────────────────┐ names │ ┌─────────────────────────────────┐ │ │ │ │ │ │ ▼ │ │ ▼ ▼┌───┬───┬─┴─┬─┴─┬───┬───────┬───┬───────┬───┬───────┬───┬───────┬───┐│ │░░░│░░░│░░░│ │ &quot;ABC&quot; │ │ &quot;XYZ&quot; │ │ &quot;zoo&quot; │ │ &quot;cat&quot; │ │└───┴─┬─┴───┴───┴───┴───────┴───┴───────┴───┴───────┴───┴───────┴───┘ │ ▲ └─────────────────┘ 这里注意到原来names[1]指向的字符串&quot;XYZ&quot;并没有改变，仅仅是将names[1]的引用从指向&quot;XYZ&quot;改成了指向&quot;cat&quot;，其结果是字符串&quot;XYZ&quot;再也无法通过names[1]访问到了。 对“指向”有了更深入的理解后，试解释如下代码： 12345678910// 数组public class Main &#123; public static void main(String[] args) &#123; String[] names = &#123;&quot;ABC&quot;, &quot;XYZ&quot;, &quot;zoo&quot;&#125;; String s = names[1]; names[1] = &quot;cat&quot;; System.out.println(s); // s是&quot;XYZ&quot;还是&quot;cat&quot;? &#125;&#125; 小结数组是同一数据类型的集合，数组一旦创建后，大小就不可变； 可以通过索引访问数组元素，但索引超出范围将报错； 数组元素可以是值类型（如int）或引用类型（如String），但数组本身是引用类型；","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"01-Java快速入门","slug":"Java/01-Java快速入门","permalink":"http://example.com/categories/Java/01-Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"name":"--01-Java程序基础","slug":"Java/01-Java快速入门/01-Java程序基础","permalink":"http://example.com/categories/Java/01-Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/01-Java%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java-01-01-06-字符和字符串","slug":"liaoxuefeng/01-Java快速入门/01-Java程序基础/06-字符和字符串","date":"2020-07-31T22:00:00.000Z","updated":"2020-08-14T18:36:34.101Z","comments":true,"path":"2020/08/01/liaoxuefeng/01-Java快速入门/01-Java程序基础/06-字符和字符串/","link":"","permalink":"http://example.com/2020/08/01/liaoxuefeng/01-Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/01-Java%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/06-%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"在Java中，字符和字符串是两个不同的类型。 字符类型字符类型char是基本数据类型，它是character的缩写。一个char保存一个Unicode字符： 12char c1 = &#x27;A&#x27;;char c2 = &#x27;中&#x27;; 因为Java在内存中总是使用Unicode表示字符，所以，一个英文字符和一个中文字符都用一个char类型表示，它们都占用两个字节。要显示一个字符的Unicode编码，只需将char类型直接赋值给int类型即可： 12int n1 = &#x27;A&#x27;; // 字母“A”的Unicodde编码是65int n2 = &#x27;中&#x27;; // 汉字“中”的Unicode编码是20013 还可以直接用转义字符\\u+Unicode编码来表示一个字符： 123// 注意是十六进制:char c3 = &#x27;\\u0041&#x27;; // &#x27;A&#x27;，因为十六进制0041 = 十进制65char c4 = &#x27;\\u4e2d&#x27;; // &#x27;中&#x27;，因为十六进制4e2d = 十进制20013 字符串类型和char类型不同，字符串类型String是引用类型，我们用双引号&quot;...&quot;表示字符串。一个字符串可以存储0个到任意个字符： 1234String s = &quot;&quot;; // 空字符串，包含0个字符String s1 = &quot;A&quot;; // 包含一个字符String s2 = &quot;ABC&quot;; // 包含3个字符String s3 = &quot;中文 ABC&quot;; // 包含6个字符，其中有一个空格 因为字符串使用双引号&quot;...&quot;表示开始和结束，那如果字符串本身恰好包含一个&quot;字符怎么表示？例如，&quot;abc&quot;xyz&quot;，编译器就无法判断中间的引号究竟是字符串的一部分还是表示字符串结束。这个时候，我们需要借助转义字符\\： 1String s = &quot;abc\\&quot;xyz&quot;; // 包含7个字符: a, b, c, &quot;, x, y, z 因为\\是转义字符，所以，两个\\\\表示一个\\字符： 1String s = &quot;abc\\\\xyz&quot;; // 包含7个字符: a, b, c, \\, x, y, z 常见的转义字符包括： \\&quot; 表示字符&quot; \\&#39; 表示字符&#39; \\\\ 表示字符\\ \\n 表示换行符 \\r 表示回车符 \\t 表示Tab \\u#### 表示一个Unicode编码的字符 例如： 1String s = &quot;ABC\\n\\u4e2d\\u6587&quot;; // 包含6个字符: A, B, C, 换行符, 中, 文 字符串连接Java的编译器对字符串做了特殊照顾，可以使用+连接任意字符串和其他数据类型，这样极大地方便了字符串的处理。例如： 12345678910// 字符串连接public class Main &#123; public static void main(String[] args) &#123; String s1 = &quot;Hello&quot;; String s2 = &quot;world&quot;; String s = s1 + &quot; &quot; + s2 + &quot;!&quot;; System.out.println(s); &#125;&#125; 如果用+连接字符串和其他数据类型，会将其他数据类型先自动转型为字符串，再连接： 123456789// 字符串连接public class Main &#123; public static void main(String[] args) &#123; int age = 25; String s = &quot;age is &quot; + age; System.out.println(s); &#125;&#125; 多行字符串如果我们要表示多行字符串，使用+号连接会非常不方便： 123String s = &quot;first line \\n&quot; + &quot;second line \\n&quot; + &quot;end&quot;; 从Java 13开始，字符串可以用&quot;&quot;&quot;...&quot;&quot;&quot;表示多行字符串（Text Blocks）了。举个例子： 12345678910111213// 多行字符串public class Main &#123; public static void main(String[] args) &#123; String s = &quot;&quot;&quot; SELECT * FROM users WHERE id &gt; 100 ORDER BY name DESC &quot;&quot;&quot;; System.out.println(s); &#125;&#125; 上述多行字符串实际上是5行，在最后一个DESC后面还有一个\\n。如果我们不想在字符串末尾加一个\\n，就需要这么写： 12345String s = &quot;&quot;&quot; SELECT * FROM users WHERE id &gt; 100 ORDER BY name DESC&quot;&quot;&quot;; 还需要注意到，多行字符串前面共同的空格会被去掉，即： 123456String s = &quot;&quot;&quot;...........SELECT * FROM........... users...........WHERE id &gt; 100...........ORDER BY name DESC...........&quot;&quot;&quot;; 用.标注的空格都会被去掉。 如果多行字符串的排版不规则，那么，去掉的空格就会变成这样： 123456String s = &quot;&quot;&quot;......... SELECT * FROM......... users.........WHERE id &gt; 100......... ORDER BY name DESC......... &quot;&quot;&quot;; 即总是以最短的行首空格为基准。 最后，由于多行字符串是作为预览特性（Preview Language Features）实现的，编译的时候，我们还需要给编译器加上参数： 1javac --source 14 --enable-preview Main.java 不可变特性Java的字符串除了是一个引用类型外，还有个重要特点，就是字符串不可变。考察以下代码： 12345678910// 字符串不可变public class Main &#123; public static void main(String[] args) &#123; String s = &quot;hello&quot;; System.out.println(s); // 显示 hello s = &quot;world&quot;; System.out.println(s); // 显示 world &#125;&#125; 观察执行结果，难道字符串s变了吗？其实变的不是字符串，而是变量s的“指向”。 执行String s = &quot;hello&quot;;时，JVM虚拟机先创建字符串&quot;hello&quot;，然后，把字符串变量s指向它： 123456 s │ ▼┌───┬───────────┬───┐│ │ &quot;hello&quot; │ │└───┴───────────┴───┘ 紧接着，执行s = &quot;world&quot;;时，JVM虚拟机先创建字符串&quot;world&quot;，然后，把字符串变量s指向它： 123456 s ──────────────┐ │ ▼┌───┬───────────┬───┬───────────┬───┐│ │ &quot;hello&quot; │ │ &quot;world&quot; │ │└───┴───────────┴───┴───────────┴───┘ 原来的字符串&quot;hello&quot;还在，只是我们无法通过变量s访问它而已。因此，字符串的不可变是指字符串内容不可变。 理解了引用类型的“指向”后，试解释下面的代码输出： 12345678910// 字符串不可变public class Main &#123; public static void main(String[] args) &#123; String s = &quot;hello&quot;; String t = s; s = &quot;world&quot;; System.out.println(t); // t是&quot;hello&quot;还是&quot;world&quot;? &#125;&#125; 空值null引用类型的变量可以指向一个空值null，它表示不存在，即该变量不指向任何对象。例如： 1234String s1 &#x3D; null; &#x2F;&#x2F; s1是nullString s2; &#x2F;&#x2F; 没有赋初始值，s2也是nullString s3 &#x3D; s1; &#x2F;&#x2F; s3也是nullString s4 &#x3D; &quot;&quot;; &#x2F;&#x2F; s4指向空字符串，不是null 注意要区分空值null和空字符串&quot;&quot;，空字符串是一个有效的字符串对象，它不等于null。 练习请将一组int值视为字符的Unicode编码，然后将它们拼成一个字符串： 123456789101112131415/** * char and String */public class JoinChar &#123; public static void main(String[] args) &#123; // 请将下面一组int值视为字符的Unicode码，把它们拼成一个字符串： int a = 72; int b = 105; int c = 65281; String s = &quot;&quot; + (char)a + (char)b + (char)c; System.out.println(s); &#125;&#125; 小结Java的字符类型char是基本类型，字符串类型String是引用类型； 基本类型的变量是“持有”某个数值，引用类型的变量是“指向”某个对象； 引用类型的变量可以是空值null； 要区分空值null和空字符串&quot;&quot;。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"01-Java快速入门","slug":"Java/01-Java快速入门","permalink":"http://example.com/categories/Java/01-Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"name":"--01-Java程序基础","slug":"Java/01-Java快速入门/01-Java程序基础","permalink":"http://example.com/categories/Java/01-Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/01-Java%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java-01-01-05-布尔运算","slug":"liaoxuefeng/01-Java快速入门/01-Java程序基础/05-布尔运算","date":"2020-07-31T21:00:00.000Z","updated":"2020-08-14T18:36:31.599Z","comments":true,"path":"2020/08/01/liaoxuefeng/01-Java快速入门/01-Java程序基础/05-布尔运算/","link":"","permalink":"http://example.com/2020/08/01/liaoxuefeng/01-Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/01-Java%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/05-%E5%B8%83%E5%B0%94%E8%BF%90%E7%AE%97/","excerpt":"","text":"对于布尔类型boolean，永远只有true和false两个值。 布尔运算是一种关系运算，包括以下几类： 比较运算符：&gt;，&gt;=，&lt;，&lt;=，==，!= 与运算 &amp;&amp; 或运算 || 非运算 ! 下面是一些示例： 123456boolean isGreater = 5 &gt; 3; // trueint age = 12;boolean isZero = age == 0; // falseboolean isNonZero = !isZero; // trueboolean isAdult = age &gt;= 18; // falseboolean isTeenager = age &gt;6 &amp;&amp; age &lt;18; // true 关系运算符的优先级从高到低依次是： ! &gt;，&gt;=，&lt;，&lt;= ==，!= &amp;&amp; || 短路运算布尔运算的一个重要特点是短路运算。如果一个布尔运算的表达式能提前确定结果，则后续的计算不再执行，直接返回结果。 因为false &amp;&amp; x的结果总是false，无论x是true还是false，因此，与运算在确定第一个值为false后，不再继续计算，而是直接返回false。 我们考察以下代码： 123456789// 短路运算public class Main &#123; public static void main(String[] args) &#123; boolean b = 5 &lt; 3; boolean result = b &amp;&amp; (5 / 0 &gt; 0); System.out.println(result); &#125;&#125; 如果没有短路运算，&amp;&amp;后面的表达式会由于除数为0而报错，但实际上该语句并未报错，原因在于与运算是短路运算符，提前计算出了结果false。 如果变量b的值为true，则表达式变为true &amp;&amp; (5 / 0 &gt; 0)。因为无法进行短路运算，该表达式必定会由于除数为0而报错，可以自行测试。 类似的，对于||运算，只要能确定第一个值为true，后续计算也不再进行，而是直接返回true： 1boolean result = true || (5 / 0 &gt; 0); // true 三元运算符Java还提供一个三元运算符b ? x : y，它根据第一个布尔表达式的结果，分别返回后续两个表达式之一的计算结果。示例： 123456789// 三元运算public class Main &#123; public static void main(String[] args) &#123; int n = -100; int x = n &gt;= 0 ? n : -n; System.out.println(x); &#125;&#125; 上述语句的意思是，判断n &gt;= 0是否成立，如果为true，则返回n，否则返回-n。这实际上是一个求绝对值的表达式。 注意到三元运算b ? x : y会首先计算b，如果b为true，则只计算x，否则，只计算y。此外，x和y的类型必须相同，因为返回值不是boolean，而是x和y之一。 练习判断指定年龄是否是小学生（6～12岁）： 123456789101112131415// 布尔运算/** * Is primary student? */public class PrimaryStudent &#123; public static void main(String[] args) &#123; int age = 7; // primary student的定义: 6~12岁 boolean isPrimaryStudent = (age&gt;=6 &amp;&amp; age&lt;=12) ? true : false; System.out.println(isPrimaryStudent ? &quot;Yes&quot; : &quot;No&quot;); &#125;&#125; 小结与运算和或运算是短路运算； 三元运算b ? x : y后面的类型必须相同，三元运算也是“短路运算”，只计算x或y。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"01-Java快速入门","slug":"Java/01-Java快速入门","permalink":"http://example.com/categories/Java/01-Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"name":"--01-Java程序基础","slug":"Java/01-Java快速入门/01-Java程序基础","permalink":"http://example.com/categories/Java/01-Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/01-Java%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java-01-01-04-浮点数运算","slug":"liaoxuefeng/01-Java快速入门/01-Java程序基础/04-浮点数运算","date":"2020-07-31T20:00:00.000Z","updated":"2020-08-14T18:36:28.900Z","comments":true,"path":"2020/08/01/liaoxuefeng/01-Java快速入门/01-Java程序基础/04-浮点数运算/","link":"","permalink":"http://example.com/2020/08/01/liaoxuefeng/01-Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/01-Java%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/04-%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97/","excerpt":"","text":"浮点数运算和整数运算相比，只能进行加减乘除这些数值计算，不能做位运算和移位运算。 在计算机中，浮点数虽然表示的范围大，但是，浮点数有个非常重要的特点，就是浮点数常常无法精确表示。 举个栗子： 浮点数0.1在计算机中就无法精确表示，因为十进制的0.1换算成二进制是一个无限循环小数，很显然，无论使用float还是double，都只能存储一个0.1的近似值。但是，0.5这个浮点数又可以精确地表示。 因为浮点数常常无法精确表示，因此，浮点数运算会产生误差： 1234567891011// 浮点数运算误差public class Main &#123; public static void main(String[] args) &#123; double x = 1.0 / 10; double y = 1 - 9.0 / 10; // 观察x和y是否相等: System.out.println(x); System.out.println(y); &#125;&#125; 由于浮点数存在运算误差，所以比较两个浮点数是否相等常常会出现错误的结果。正确的比较方法是判断两个浮点数之差的绝对值是否小于一个很小的数： 12345678// 比较x和y是否相等，先计算其差的绝对值:double r = Math.abs(x - y);// 再判断绝对值是否足够小:if (r &lt; 0.00001) &#123; // 可以认为相等&#125; else &#123; // 不相等&#125; 浮点数在内存的表示方法和整数比更加复杂。Java的浮点数完全遵循IEEE-754标准，这也是绝大多数计算机平台都支持的浮点数标准表示方法。 类型提升如果参与运算的两个数其中一个是整型，那么整型可以自动提升到浮点型： 123456789// 类型提升public class Main &#123; public static void main(String[] args) &#123; int n = 5; double d = 1.2 + 24.0 / n; // 6.0 System.out.println(d); &#125;&#125; 需要特别注意，在一个复杂的四则运算中，两个整数的运算不会出现自动提升的情况。例如： 1double d = 1.2 + 24 / 5; // 5.2 计算结果为5.2，原因是编译器计算24 / 5这个子表达式时，按两个整数进行运算，结果仍为整数4。 溢出整数运算在除数为0时会报错，而浮点数运算在除数为0时，不会报错，但会返回几个特殊值： NaN表示Not a Number Infinity表示无穷大 -Infinity表示负无穷大 例如： 123double d1 = 0.0 / 0; // NaNdouble d2 = 1.0 / 0; // Infinitydouble d3 = -1.0 / 0; // -Infinity 这三种特殊值在实际运算中很少碰到，我们只需要了解即可。 强制转型可以将浮点数强制转型为整数。在转型时，浮点数的小数部分会被丢掉。如果转型后超过了整型能表示的最大范围，将返回整型的最大值。例如： 12345int n1 = (int) 12.3; // 12int n2 = (int) 12.7; // 12int n2 = (int) -12.7; // -12int n3 = (int) (12.7 + 0.5); // 13int n4 = (int) 1.2e20; // 2147483647 如果要进行四舍五入，可以对浮点数加上0.5再强制转型： 123456789// 四舍五入public class Main &#123; public static void main(String[] args) &#123; double d = 2.6; int n = (int) (d + 0.5); System.out.println(n); &#125;&#125; 练习根据一元二次方程$ax^2+bx+c=0$的求根公式：$\\frac{-b\\pm\\sqrt{b^2-4ac}}{2}$ 计算出一元二次方程的两个解： 12345678910111213141516171819202122// 一元二次方程/** * 求解 一元二次方程ax^2+bx+c=0 */public class Main &#123; public static void main(String[] args) &#123; // x*x + 3*x - 4 = 0 double a = 1.0; double b = 3.0; double c = -4.0; // 求平方根可用 Math.sqrt(): // double x = Math.sqrt(2)); // ==&gt; 1.414 // TODO: double r1 = (-b + Math.sqrt(b*b - 4*a*c)) / 2; double r2 = (-b - Math.sqrt(b*b - 4*a*c)) / 2; System.out.println(r1 + &quot;, &quot; + r2); System.out.println(r1 == 1 &amp;&amp; r2 == -4 ? &quot;测试通过&quot; : &quot;测试失败&quot;); &#125;&#125; 小结浮点数常常无法精确表示，并且浮点数的运算结果可能有误差； 比较两个浮点数通常比较它们的绝对值之差是否小于一个特定值； 整型和浮点型运算时，整型会自动提升为浮点型； 可以将浮点型强制转为整型，但超出范围后将始终返回整型的最大值。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"01-Java快速入门","slug":"Java/01-Java快速入门","permalink":"http://example.com/categories/Java/01-Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"name":"--01-Java程序基础","slug":"Java/01-Java快速入门/01-Java程序基础","permalink":"http://example.com/categories/Java/01-Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/01-Java%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java-01-01-03-整数运算","slug":"liaoxuefeng/01-Java快速入门/01-Java程序基础/03-整数运算","date":"2020-07-31T19:00:00.000Z","updated":"2020-08-14T18:36:25.912Z","comments":true,"path":"2020/08/01/liaoxuefeng/01-Java快速入门/01-Java程序基础/03-整数运算/","link":"","permalink":"http://example.com/2020/08/01/liaoxuefeng/01-Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/01-Java%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/03-%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97/","excerpt":"","text":"Java的整数运算遵循四则运算规则，可以使用任意嵌套的小括号。四则运算规则和初等数学一致。例如： 12345678910// 四则运算public class Main &#123; public static void main(String[] args) &#123; int i = (100 + 200) * (99 - 88); // 3300 int n = 7 * (5 + (i - 9)); // 23072 System.out.println(i); System.out.println(n); &#125;&#125; 整数的数值表示不但是精确的，而且整数运算永远是精确的，即使是除法也是精确的，因为两个整数相除只能得到结果的整数部分： 1int x = 12345 / 67; // 184 求余运算使用%： 1int y = 12345 % 67; // 12345÷67的余数是17 特别注意：整数的除法对于除数为0时运行时将报错，但编译不会报错。 溢出要特别注意，整数由于存在范围限制，如果计算结果超出了范围，就会产生溢出，而溢出不会出错，却会得到一个奇怪的结果： 12345678910// 运算溢出public class Main &#123; public static void main(String[] args) &#123; int x = 2147483640; int y = 15; int sum = x + y; System.out.println(sum); // -2147483641 &#125;&#125; 要解释上述结果，我们把整数2147483640和15换成二进制做加法： 1234 0111 1111 1111 1111 1111 1111 1111 1000+ 0000 0000 0000 0000 0000 0000 0000 1111----------------------------------------- 1000 0000 0000 0000 0000 0000 0000 0111 由于最高位计算结果为1，因此，加法结果变成了一个负数。 要解决上面的问题，可以把int换成long类型，由于long可表示的整型范围更大，所以结果就不会溢出： 1234long x = 2147483640;long y = 15;long sum = x + y;System.out.println(sum); // 2147483655 还有一种简写的运算符，即+=，-=，*=，/=，它们的使用方法如下： 12n += 100; // 3409, 相当于 n = n + 100;n -= 100; // 3309, 相当于 n = n - 100; 自增/自减Java还提供了++运算和--运算，它们可以对一个整数进行加1和减1的操作： 1234567891011 // 自增/自减运算public class Main &#123; public static void main(String[] args) &#123; int n = 3300; n++; // 3301, 相当于 n = n + 1; n--; // 3300, 相当于 n = n - 1; int y = 100 + (++n); // 不要这么写 System.out.println(y); &#125;&#125; 注意++写在前面和后面计算结果是不同的，++n表示先加1再引用n，n++表示先引用n再加1。不建议把++运算混入到常规运算中，容易自己把自己搞懵了。 移位运算在计算机中，整数总是以二进制的形式表示。例如，int类型的整数7使用4字节表示的二进制如下： 100000000 0000000 0000000 00000111 可以对整数进行移位运算。对整数7左移1位将得到整数14，左移两位将得到整数28： 12345int n = 7; // 00000000 00000000 00000000 00000111 = 7int a = n &lt;&lt; 1; // 00000000 00000000 00000000 00001110 = 14int b = n &lt;&lt; 2; // 00000000 00000000 00000000 00011100 = 28int c = n &lt;&lt; 28; // 01110000 00000000 00000000 00000000 = 1879048192int d = n &lt;&lt; 29; // 11100000 00000000 00000000 00000000 = -536870912 左移29位时，由于最高位变成1，因此结果变成了负数。 类似的，对整数28进行右移，结果如下： 1234int n = 7; // 00000000 00000000 00000000 00000111 = 7int a = n &gt;&gt; 1; // 00000000 00000000 00000000 00000011 = 3int b = n &gt;&gt; 2; // 00000000 00000000 00000000 00000001 = 1int c = n &gt;&gt; 3; // 00000000 00000000 00000000 00000000 = 0 如果对一个负数进行右移，最高位的1不动，结果仍然是一个负数： 12345int n = -536870912;int a = n &gt;&gt; 1; // 11110000 00000000 00000000 00000000 = -268435456int b = n &gt;&gt; 2; // 11111000 00000000 00000000 00000000 = -134217728int c = n &gt;&gt; 28; // 11111111 11111111 11111111 11111110 = -2int d = n &gt;&gt; 29; // 11111111 11111111 11111111 11111111 = -1 还有一种无符号的右移运算，使用&gt;&gt;&gt;，它的特点是不管符号位，右移后高位总是补0，因此，对一个负数进行&gt;&gt;&gt;右移，它会变成正数，原因是最高位的1变成了0： 12345int n = -536870912;int a = n &gt;&gt;&gt; 1; // 01110000 00000000 00000000 00000000 = 1879048192int b = n &gt;&gt;&gt; 2; // 00111000 00000000 00000000 00000000 = 939524096int c = n &gt;&gt;&gt; 29; // 00000000 00000000 00000000 00000111 = 7int d = n &gt;&gt;&gt; 31; // 00000000 00000000 00000000 00000001 = 1 对byte和short类型进行移位时，会首先转换为int再进行位移。 仔细观察可发现，左移实际上就是不断地×2，右移实际上就是不断地÷2。 位运算位运算是按位进行与、或、非和异或的运算。 与运算的规则是，必须两个数同时为1，结果才为1： 1234n = 0 &amp; 0; // 0n = 0 &amp; 1; // 0n = 1 &amp; 0; // 0n = 1 &amp; 1; // 1 或运算的规则是，只要任意一个为1，结果就为1： 1234n = 0 | 0; // 0n = 0 | 1; // 1n = 1 | 0; // 1n = 1 | 1; // 1 非运算的规则是，0和1互换： 12n = ~0; // 1n = ~1; // 0 异或运算的规则是，如果两个数不同，结果为1，否则为0： 1234n = 0 ^ 0; // 0n = 0 ^ 1; // 1n = 1 ^ 0; // 1n = 1 ^ 1; // 0 对两个整数进行位运算，实际上就是按位对齐，然后依次对每一位进行运算。例如： 123456789// 位运算public class Main &#123; public static void main(String[] args) &#123; int i = 167776589; // 00001010 00000000 00010001 01001101 int n = 167776512; // 00001010 00000000 00010001 00000000 System.out.println(i &amp; n); // 167776512 &#125;&#125; 上述按位与运算实际上可以看作两个整数表示的IP地址10.0.17.77和10.0.17.0，通过与运算，可以快速判断一个IP是否在给定的网段内。 运算优先级在Java的计算表达式中，运算优先级从高到低依次是： () ! ~ ++ -- * / % + - &lt;&lt; &gt;&gt; &gt;&gt;&gt; &amp; | += -= *= /= 记不住也没关系，只需要加括号就可以保证运算的优先级正确。 类型自动提升与强制转型在运算过程中，如果参与运算的两个数类型不一致，那么计算结果为较大类型的整型。例如，short和int计算，结果总是int，原因是short首先自动被转型为int： 12345678910// 类型自动提升与强制转型public class Main &#123; public static void main(String[] args) &#123; short s = 1234; int i = 123456; int x = s + i; // s自动转型为int short y = s + i; // 编译错误! &#125;&#125; 也可以将结果强制转型，即将大范围的整数转型为小范围的整数。强制转型使用(类型)，例如，将int强制转型为short： 12int i = 12345;short s = (short) i; // 12345 要注意，超出范围的强制转型会得到错误的结果，原因是转型时，int的两个高位字节直接被扔掉，仅保留了低位的两个字节： 123456789101112// 强制转换public class Main &#123; public static void main(String[] args) &#123; int i1 = 1234567; short s1 = (short) i1; // -10617 System.out.println(s1); int i2 = 12345678; short s2 = (short) i2; // 24910 System.out.println(s2); &#125;&#125; 因此，强制转型的结果很可能是错的。 练习计算前N个自然数的和可以根据公示：$\\frac{(N + 1)N}{2}$ 请根据公式计算前N个自然数的和： 123456789101112131415// 计算前N个自然数的和/** * Sum of integers. */public class SumOfInteger &#123; public static void main(String[] args) &#123; int n = 100; // TODO: sum = 1 + 2 + ... + n int sum = (n + 1) * n / 2; System.out.println(sum); &#125;&#125; 小结整数运算的结果永远是精确的； 运算结果会自动提升； 可以强制转型，但超出范围的强制转型会得到错误的结果； 应该选择合适范围的整型（int或long），没有必要为了节省内存而使用byte和short进行整数运算。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"01-Java快速入门","slug":"Java/01-Java快速入门","permalink":"http://example.com/categories/Java/01-Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"name":"--01-Java程序基础","slug":"Java/01-Java快速入门/01-Java程序基础","permalink":"http://example.com/categories/Java/01-Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/01-Java%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java-01-01-02-变量和数据类型","slug":"liaoxuefeng/01-Java快速入门/01-Java程序基础/02-变量和数据类型","date":"2020-07-31T18:00:00.000Z","updated":"2020-12-01T12:12:09.088Z","comments":true,"path":"2020/08/01/liaoxuefeng/01-Java快速入门/01-Java程序基础/02-变量和数据类型/","link":"","permalink":"http://example.com/2020/08/01/liaoxuefeng/01-Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/01-Java%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/02-%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"变量什么是变量？ 变量就是初中数学的代数的概念，例如一个简单的方程，x，y都是变量： $y=x^2+1$ 在Java中，变量分为两种：基本类型的变量和引用类型的变量。 我们先讨论基本类型的变量。 在Java中，变量必须先定义后使用，在定义变量的时候，可以给它一个初始值。例如： 1int x = 1; 上述语句定义了一个整型int类型的变量，名称为x，初始值为1。 不写初始值，就相当于给它指定了默认值。默认值总是0。 来看一个完整的定义变量，然后打印变量值的例子： 12345678// 定义并打印变量 public class Main &#123; public static void main(String[] args) &#123; int x = 100; // 定义int类型变量x，并赋予初始值100 System.out.println(x); // 打印该变量的值 &#125;&#125; 变量的一个重要特点是可以重新赋值。例如，对变量x，先赋值100，再赋值200，观察两次打印的结果： 12345678910// 重新赋值变量public class Main &#123; public static void main(String[] args) &#123; int x = 100; // 定义int类型变量x，并赋予初始值100 System.out.println(x); // 打印该变量的值，观察是否为100 x = 200; // 重新赋值为200 System.out.println(x); // 打印该变量的值，观察是否为200 &#125;&#125; 注意到第一次定义变量x的时候，需要指定变量类型int，因此使用语句int x = 100;。而第二次重新赋值的时候，变量x已经存在了，不能再重复定义，因此不能指定变量类型int，必须使用语句x = 200;。 变量不但可以重新赋值，还可以赋值给其他变量。让我们来看一个例子： 123456789101112131415161718// 变量之间的赋值public class Main &#123; public static void main(String[] args) &#123; int n = 100; // 定义变量n，同时赋值为100 System.out.println(&quot;n = &quot; + n); // 打印n的值 n = 200; // 变量n赋值为200 System.out.println(&quot;n = &quot; + n); // 打印n的值 int x = n; // 变量x赋值为n（n的值为200，因此赋值后x的值也是200） System.out.println(&quot;x = &quot; + x); // 打印x的值 x = x + 100; // 变量x赋值为x+100（x的值为200，因此赋值后x的值是200+100=300） System.out.println(&quot;x = &quot; + x); // 打印x的值 System.out.println(&quot;n = &quot; + n); // 再次打印n的值，n应该是200还是300？ &#125;&#125; 我们一行一行地分析代码执行流程： 执行int n = 100;，该语句定义了变量n，同时赋值为100，因此，JVM在内存中为变量n分配一个“存储单元”，填入值100： 123456 n │ ▼┌───┬───┬───┬───┬───┬───┬───┐│ │100│ │ │ │ │ │└───┴───┴───┴───┴───┴───┴───┘ 执行n = 200;时，JVM把200写入变量n的存储单元，因此，原有的值被覆盖，现在n的值为200： 123456 n │ ▼┌───┬───┬───┬───┬───┬───┬───┐│ │200│ │ │ │ │ │└───┴───┴───┴───┴───┴───┴───┘ 执行int x = n;时，定义了一个新的变量x，同时对x赋值，因此，JVM需要新分配一个存储单元给变量x，并写入和变量n一样的值，结果是变量x的值也变为200： 123456 n x │ │ ▼ ▼┌───┬───┬───┬───┬───┬───┬───┐│ │200│ │ │200│ │ │└───┴───┴───┴───┴───┴───┴───┘ 执行x = x + 100;时，JVM首先计算等式右边的值x + 100，结果为300（因为此刻x的值为200），然后，将结果300写入x的存储单元，因此，变量x最终的值变为300： 123456 n x │ │ ▼ ▼┌───┬───┬───┬───┬───┬───┬───┐│ │200│ │ │300│ │ │└───┴───┴───┴───┴───┴───┴───┘ 可见，变量可以反复赋值。注意，等号=是赋值语句，不是数学意义上的相等，否则无法解释x = x + 100。 基本数据类型基本数据类型是CPU可以直接进行运算的类型。Java定义了以下几种基本数据类型： 整数类型：byte，short，int，long 浮点数类型：float，double 字符类型：char 布尔类型：boolean Java定义的这些基本数据类型有什么区别呢？要了解这些区别，我们就必须简单了解一下计算机内存的基本结构。 计算机内存的最小存储单元是字节（byte），一个字节就是一个8位二进制数，即8个bit。它的二进制表示范围从00000000 ~ 11111111，换算成十进制是0 ~ 255，换算成十六进制是00 ~ ff。 内存单元从0开始编号，称为内存地址。每个内存单元可以看作一间房间，内存地址就是门牌号。 1234 0 1 2 3 4 5 6 ...┌───┬───┬───┬───┬───┬───┬───┐│ │ │ │ │ │ │ │...└───┴───┴───┴───┴───┴───┴───┘ 一个字节是1byte，1024字节是1K，1024K是1M，1024M是1G，1024G是1T。一个拥有4T内存的计算机的字节数量就是： 123454T &#x3D; 4 x 1024G &#x3D; 4 x 1024 x 1024M &#x3D; 4 x 1024 x 1024 x 1024K &#x3D; 4 x 1024 x 1024 x 1024 x 1024 &#x3D; 4398046511104 不同的数据类型占用的字节数不一样。我们看一下Java基本数据类型占用的字节数： 123456789101112131415161718192021 ┌───┐ byte │ │ └───┘ ┌───┬───┐ short │ │ │ └───┴───┘ ┌───┬───┬───┬───┐ int │ │ │ │ │ └───┴───┴───┴───┘ ┌───┬───┬───┬───┬───┬───┬───┬───┐ long │ │ │ │ │ │ │ │ │ └───┴───┴───┴───┴───┴───┴───┴───┘ ┌───┬───┬───┬───┐ float │ │ │ │ │ └───┴───┴───┴───┘ ┌───┬───┬───┬───┬───┬───┬───┬───┐double │ │ │ │ │ │ │ │ │ └───┴───┴───┴───┴───┴───┴───┴───┘ ┌───┬───┐ char │ │ │ └───┴───┘ byte恰好就是一个字节，而long和double需要8个字节。 整型对于整型类型，Java只定义了带符号的整型，因此，最高位的bit表示符号位（0表示正数，1表示负数）。各种整型能表示的最大范围如下： byte：-128 ~ 127 short: -32768 ~ 32767 int: -2147483648 ~ 2147483647 long: -9223372036854775808 ~ 9223372036854775807 我们来看定义整型的例子： 123456789101112// 定义整型public class Main &#123; public static void main(String[] args) &#123; int i = 2147483647; int i2 = -2147483648; int i3 = 2_000_000_000; // 加下划线更容易识别 int i4 = 0xff0000; // 十六进制表示的16711680 int i5 = 0b1000000000; // 二进制表示的512 long l = 9000000000000000000L; // long型的结尾需要加L &#125;&#125; 特别注意：同一个数的不同进制的表示是完全相同的，例如15=0xf＝0b1111。 浮点型浮点类型的数就是小数，因为小数用科学计数法表示的时候，小数点是可以“浮动”的，如1234.5可以表示成$12.34510^2$，也可以表示成$1.234510^3$，所以称为浮点数。 下面是定义浮点数的例子： 12345float f1 = 3.14f;float f2 = 3.14e38f; // 科学计数法表示的3.14x10^38double d = 1.79e308;double d2 = -1.79e308;double d3 = 4.9e-324; // 科学计数法表示的4.9x10^-324 对于float类型，需要加上f后缀。 浮点数可表示的范围非常大，float类型可最大表示$3.410^{38}$，而double类型可最大表示$1.7910^{308}$。 布尔类型布尔类型boolean只有true和false两个值，布尔类型总是关系运算的计算结果： 12345boolean b1 = true;boolean b2 = false;boolean isGreater = 5 &gt; 3; // 计算结果为trueint age = 12;boolean isAdult = age &gt;= 18; // 计算结果为false Java语言对布尔类型的存储并没有做规定，因为理论上存储布尔类型只需要1 bit，但是通常JVM内部会把boolean表示为4字节整数。 字符类型字符类型char表示一个字符。Java的char类型除了可表示标准的ASCII外，还可以表示一个Unicode字符： 12345678910// 字符类型public class Main &#123; public static void main(String[] args) &#123; char a = &#x27;A&#x27;; char zh = &#x27;中&#x27;; System.out.println(a); System.out.println(zh); &#125;&#125; 注意char类型使用单引号&#39;，且仅有一个字符，要和双引号&quot;的字符串类型区分开。 引用类型除了上述基本类型的变量，剩下的都是引用类型。例如，引用类型最常用的就是String字符串： 1String s = &quot;hello&quot;; 引用类型的变量类似于C语言的指针，它内部存储一个“地址”，指向某个对象在内存的位置，后续我们介绍类的概念时会详细讨论。 常量定义变量的时候，如果加上final修饰符，这个变量就变成了常量： 1234final double PI = 3.14; // PI是一个常量double r = 5.0;double area = PI * r * r;PI = 300; // compile error! 常量在定义时进行初始化后就不可再次赋值，再次赋值会导致编译错误。 常量的作用是用有意义的变量名来避免魔术数字（Magic number），例如，不要在代码中到处写3.14，而是定义一个常量。如果将来需要提高计算精度，我们只需要在常量的定义处修改，例如，改成3.1416，而不必在所有地方替换3.14。 根据习惯，常量名通常全部大写。 var关键字有些时候，类型的名字太长，写起来比较麻烦。例如： 1StringBuilder sb = new StringBuilder(); 这个时候，如果想省略变量类型，可以使用var关键字： 1var sb = new StringBuilder(); 编译器会根据赋值语句自动推断出变量sb的类型是StringBuilder。对编译器来说，语句： 1var sb = new StringBuilder(); 实际上会自动变成： 1StringBuilder sb = new StringBuilder(); 因此，使用var定义变量，仅仅是少写了变量类型而已。 变量的作用范围在Java中，多行语句用{ }括起来。很多控制语句，例如条件判断和循环，都以{ }作为它们自身的范围，例如： 1234567891011if (...) &#123; // if开始 ... while (...) &#123; // while 开始 ... if (...) &#123; // if开始 ... &#125; // if结束 ... &#125; // while结束 ...&#125; // if结束 只要正确地嵌套这些{ }，编译器就能识别出语句块的开始和结束。而在语句块中定义的变量，它有一个作用域，就是从定义处开始，到语句块结束。超出了作用域引用这些变量，编译器会报错。举个例子： 123456789101112131415161718192021&#123; ... int i = 0; // 变量i从这里开始定义 ... &#123; ... int x = 1; // 变量x从这里开始定义 ... &#123; ... String s = &quot;hello&quot;; // 变量s从这里开始定义 ... &#125; // 变量s作用域到此结束 ... // 注意，这是一个新的变量s，它和上面的变量同名， // 但是因为作用域不同，它们是两个不同的变量: String s = &quot;hi&quot;; ... &#125; // 变量x和s作用域到此结束 ...&#125; // 变量i作用域到此结束 定义变量时，要遵循作用域最小化原则，尽量将变量定义在尽可能小的作用域，并且，不要重复使用变量名。 小结Java提供了两种变量类型：基本类型和引用类型 基本类型包括整型，浮点型，布尔型，字符型。 变量可重新赋值，等号是赋值语句，不是数学意义的等号。 常量在初始化后不可重新赋值，使用常量便于理解程序意图。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"01-Java快速入门","slug":"Java/01-Java快速入门","permalink":"http://example.com/categories/Java/01-Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"name":"--01-Java程序基础","slug":"Java/01-Java快速入门/01-Java程序基础","permalink":"http://example.com/categories/Java/01-Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/01-Java%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java-01-01-01-Java程序基本结构","slug":"liaoxuefeng/01-Java快速入门/01-Java程序基础/01-Java程序基本结构","date":"2020-07-31T17:00:00.000Z","updated":"2020-08-14T18:36:05.480Z","comments":true,"path":"2020/08/01/liaoxuefeng/01-Java快速入门/01-Java程序基础/01-Java程序基本结构/","link":"","permalink":"http://example.com/2020/08/01/liaoxuefeng/01-Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/01-Java%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/01-Java%E7%A8%8B%E5%BA%8F%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/","excerpt":"","text":"我们先剖析一个完整的Java程序，它的基本结构是什么： 123456789101112/** * 可以用来自动创建文档的注释 */public class Hello &#123; public static void main(String[] args) &#123; // 向屏幕输出文本: System.out.println(&quot;Hello, world!&quot;); /* 多行注释开始 注释内容 注释结束 */ &#125;&#125; // class定义结束 因为Java是面向对象的语言，一个程序的基本单位就是class，class是关键字，这里定义的class名字就是Hello： 123public class Hello &#123; // 类名是Hello // ...&#125; // class定义结束 类名要求： 类名必须以英文字母开头，后接字母，数字和下划线的组合 习惯以大写字母开头 要注意遵守命名习惯，好的类命名： Hello NoteBook VRPlayer 不好的类命名： hello Good123 Note_Book _World 注意到public是访问修饰符，表示该class是公开的。 不写public，也能正确编译，但是这个类将无法从命令行执行。 在class内部，可以定义若干方法（method）： 12345public class Hello &#123; public static void main(String[] args) &#123; // 方法名是main // 方法代码... &#125; // 方法定义结束&#125; 方法定义了一组执行语句，方法内部的代码将会被依次顺序执行。 这里的方法名是main，返回值是void，表示没有任何返回值。 我们注意到public除了可以修饰class外，也可以修饰方法。而关键字static是另一个修饰符，它表示静态方法，后面我们会讲解方法的类型，目前，我们只需要知道，Java入口程序规定的方法必须是静态方法，方法名必须为main，括号内的参数必须是String数组。 方法名也有命名规则，命名和class一样，但是首字母小写： 好的方法命名： main goodMorning playVR 不好的方法命名： Main good123 good_morning _playVR 在方法内部，语句才是真正的执行代码。Java的每一行语句必须以分号结束： 12345public class Hello &#123; public static void main(String[] args) &#123; System.out.println(&quot;Hello, world!&quot;); // 语句 &#125;&#125; 在Java程序中，注释是一种给人阅读的文本，不是程序的一部分，所以编译器会自动忽略注释。 Java有3种注释，第一种是单行注释，以双斜线开头，直到这一行的结尾结束： 1// 这是注释... 而多行注释以/*星号开头，以*/结束，可以有多行： 12345/*这是注释blablabla...这也是注释*/ 还有一种特殊的多行注释，以/**开头，以*/结束，如果有多行，每行通常以星号开头： 12345678910/** * 可以用来自动创建文档的注释 * * @auther 何若 */public class Hello &#123; public static void main(String[] args) &#123; System.out.println(&quot;Hello, world!&quot;); &#125;&#125; 这种特殊的多行注释需要写在类和方法的定义处，可以用于自动创建文档。 Java程序对格式没有明确的要求，多几个空格或者回车不影响程序的正确性，但是我们要养成良好的编程习惯，注意遵守Java社区约定的编码格式。 那约定的编码格式有哪些要求呢？其实我们在前面介绍的Eclipse IDE提供了快捷键Ctrl+Shift+F（macOS是⌘+⇧+F）帮助我们快速格式化代码的功能，Eclipse就是按照约定的编码格式对代码进行格式化的，所以只需要看看格式化后的代码长啥样就行了。具体的代码格式要求可以在Eclipse的设置中Java-Code Style查看。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"01-Java快速入门","slug":"Java/01-Java快速入门","permalink":"http://example.com/categories/Java/01-Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"name":"--01-Java程序基础","slug":"Java/01-Java快速入门/01-Java程序基础","permalink":"http://example.com/categories/Java/01-Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/01-Java%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]}],"categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"02-面向对象编程","slug":"Java/02-面向对象编程","permalink":"http://example.com/categories/Java/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"name":"--02-Java核心类","slug":"Java/02-面向对象编程/02-Java核心类","permalink":"http://example.com/categories/Java/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/02-Java%E6%A0%B8%E5%BF%83%E7%B1%BB/"},{"name":"--01-面向对象基础","slug":"Java/02-面向对象编程/01-面向对象基础","permalink":"http://example.com/categories/Java/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/01-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/"},{"name":"01-Java快速入门","slug":"Java/01-Java快速入门","permalink":"http://example.com/categories/Java/01-Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"name":"--03-数组操作","slug":"Java/01-Java快速入门/03-数组操作","permalink":"http://example.com/categories/Java/01-Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/03-%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/"},{"name":"--02-流程控制","slug":"Java/01-Java快速入门/02-流程控制","permalink":"http://example.com/categories/Java/01-Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/02-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"name":"--01-Java程序基础","slug":"Java/01-Java快速入门/01-Java程序基础","permalink":"http://example.com/categories/Java/01-Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/01-Java%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]}